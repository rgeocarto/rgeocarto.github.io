[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Géomatique et cartographie avec R",
    "section": "",
    "text": "Préambule\nLe logiciel R permet depuis longtemps de traiter les données spatiales, plusieurs packages forment un socle permettant la mise en œuvre de ces traitements. Les développements actuels s’appuient sur ce socle et forment un écosystème robuste qui offre aux utilisateurs la plupart des fonctionnalités autrefois réservées aux Systèmes d’Information Géographique, et cela dans un environnement favorable à la reproductibilité des résultats de recherche.\nCe manuel est destiné tant aux utilisateurs de R souhaitant mettre en place des traitements de données spatiales qu’aux utilisateurs souhaitant utiliser R pour réaliser les taches qu’ils réalisent habituellement avec un SIG.\nComment utiliser le manuel\nLes données utilisées dans ce document sont stockées dans un projet RStudio. Vous devez le télécharger puis le décompresser sur votre machine. Il vous sera ensuite possible de tester l’ensemble des manipulations proposées dans ce document au sein du projet geodata.\nTélécharger le projet\nContribution et feedback\nVous pouvez nous envoyer vos remarques et suggestions en postant une issue sur le dépôt GitHub de ce document.\n\n\n\n\n\n\n\nVoir aussi en anglais : \n\n\n\n\n\n\nGeocomputation with R - Lovelace et al. (2025)\n\n\n\n\n\n\n\nSpatial Data Science with Applications in R - Pebesma et Bivand (2023)\n\n\n\n\n\n\n\nSpatial Data Science with R and “terra” - Hijmans (2025)\n\n\n\n\n\n Pour citer le document :\nGiraud, T. et Pecout, H. (2025). Géomatique et cartographie avec R.\n\n\n\n\n\n\n\nHijmans, R. J. (2025). Spatial Data Science with R and \"terra\". https://rspatial.org\n\n\nLovelace, R., Nowosad, J. et Muenchow, J. (2025). Geocomputation with R. CRC Press. https://r.geocompx.org/\n\n\nPebesma, E. et Bivand, R. (2023). Spatial Data Science: With Applications in R. Chapman; Hall/CRC. https://doi.org/10.1201/9780429459016",
    "crumbs": [
      "*Préambule*"
    ]
  },
  {
    "objectID": "01_package_sf.html",
    "href": "01_package_sf.html",
    "title": "1  Le package sf",
    "section": "",
    "text": "1.1 Présentation\nLe package sf (Pebesma, 2018) a été publié fin 2016 par Edzer Pebesma. Ce package permet l’import, l’export, la manipulation et l’affichage de données spatiales vectorielles. Pour cela sf s’appuie sur une série de bibliothèques spatiales : GDAL (GDAL/OGR contributors, 2025) et PROJ (PROJ contributors, 2025) pour les opérations d’import, d’export et de projection, et GEOS (GEOS contributors, 2025) pour les opérations de géotraitement (buffer, intersection…).\nCe package propose des objets simples (suivant le standard simple feature) dont la manipulation est assez aisée. Une attention particulière a été portée à la compatibilité du package avec la syntaxe pipe (|&gt; ou %&gt;%) et les opérateurs du tidyverse (Wickham et al., 2019).",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Le package sf</span>"
    ]
  },
  {
    "objectID": "01_package_sf.html#présentation",
    "href": "01_package_sf.html#présentation",
    "title": "1  Le package sf",
    "section": "",
    "text": "Pebesma et Bivand (2023)\n\n\n\n\n\n\n\n\nNoteHistorique\n\n\n\nLe package sf est venu remplacer les packages sp (Pebesma et Bivand, 2005), rgeos (Bivand et Rundel, 2023) et rgdal (Bivand et al., 2023) en combinant leurs fonctionnalités dans un package unique plus ergonomique. Sur ce sujet on peut lire avec profit l’article de Bivand (2021) qui évoque l’évolution de l’écosystème spatial de R.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Le package sf</span>"
    ]
  },
  {
    "objectID": "01_package_sf.html#format-des-objets-sf",
    "href": "01_package_sf.html#format-des-objets-sf",
    "title": "1  Le package sf",
    "section": "1.2 Format des objets sf",
    "text": "1.2 Format des objets sf\n\nLes objets sf sont des data.frame dont l’une des colonnes contient des géométries. Cette colonne est de la classe sfc (simple feature column) et chaque individu de la colonne est un sfg (simple feature geometry).\nCe format est très pratique dans la mesure où les données et les géométries sont intrinsèquement liées dans un même objet.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Le package sf</span>"
    ]
  },
  {
    "objectID": "01_package_sf.html#ressources",
    "href": "01_package_sf.html#ressources",
    "title": "1  Le package sf",
    "section": "1.3 Ressources",
    "text": "1.3 Ressources\n\n\n\n\n\n\nSite web de sf\n\n\n\n\n\n\n\nCheat sheet",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Le package sf</span>"
    ]
  },
  {
    "objectID": "01_package_sf.html#exercice",
    "href": "01_package_sf.html#exercice",
    "title": "1  Le package sf",
    "section": "Exercice",
    "text": "Exercice\n\nLes données utilisées dans ce document sont stockées dans un projet RStudio. Vous devez le télécharger puis le décompresser sur votre machine. Il vous sera ensuite possible de tester l’ensemble des manipulations proposées dans ce document au sein du projet geodata.\nTélécharger le projet\nNous utiliserons principalement le package sf dans la suite de ce document.\nInstallez le en utilisant la fonction install.packages().\n\n\n\n\n\nBivand, R. (2021). Progress in the R ecosystem for representing and handling spatial data. Journal of Geographical Systems, 23(4), 515‑546. https://doi.org/10.1007/s10109-020-00336-0\n\n\nBivand, R., Keitt, T. et Rowlingson, B. (2023). rgdal: Bindings for the ’Geospatial’ Data Abstraction Library. https://CRAN.R-project.org/package=rgdal\n\n\nBivand, R. et Rundel, C. (2023). rgeos: Interface to Geometry Engine - Open Source (’GEOS’). https://CRAN.R-project.org/package=rgeos\n\n\nGDAL/OGR contributors. (2025). GDAL/OGR Geospatial Data Abstraction software Library. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.5884351\n\n\nGEOS contributors. (2025). GEOS computational geometry library. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.11396894\n\n\nPebesma, E. (2018). Simple Features for R: Standardized Support for Spatial Vector Data. The R Journal, 10(1), 439‑446. https://doi.org/10.32614/RJ-2018-009\n\n\nPebesma, E. et Bivand, R. (2005). Classes and methods for spatial data in R. R News, 5(2), 9‑13. https://CRAN.R-project.org/doc/Rnews/\n\n\nPebesma, E. et Bivand, R. (2023). Spatial Data Science: With Applications in R. Chapman; Hall/CRC. https://doi.org/10.1201/9780429459016\n\n\nPROJ contributors. (2025). PROJ coordinate transformation software library. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.5884394\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L. D., François, R., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M., Pedersen, T. L., Miller, E., Bache, S. M., Müller, K., Ooms, J., Robinson, D., Seidel, D. P., Spinu, V., Takahashi, K., et al.Yutani, H. (2019). Welcome to the tidyverse. Journal of Open Source Software, 4(43), 1686. https://doi.org/10.21105/joss.01686",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Le package sf</span>"
    ]
  },
  {
    "objectID": "02_import_sf.html",
    "href": "02_import_sf.html",
    "title": "2  Import et export",
    "section": "",
    "text": "2.1 Import\nLes fonctions st_read() et st_write() permettent d’importer et d’exporter de nombreux types de fichiers.\nLes lignes suivantes importent la couche des communes du département du Lot mise à disposition dans le fichier geopackage lot.gpkg.\nlibrary(sf)\n\n#&gt; Linking to GEOS 3.13.1, GDAL 3.10.3, PROJ 9.6.0; sf_use_s2() is TRUE\n\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\")\n\n#&gt; Reading layer `communes' from data source \n#&gt;   `/home/tim/Documents/prj/rgeocarto.github.io/data/lot.gpkg' \n#&gt;   using driver `GPKG'\n#&gt; Simple feature collection with 313 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\nclass(com)\n\n#&gt; [1] \"sf\"         \"data.frame\"\nLa fonction st_read() importe les couches géographiques au format sf.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Import et export</span>"
    ]
  },
  {
    "objectID": "02_import_sf.html#import",
    "href": "02_import_sf.html#import",
    "title": "2  Import et export",
    "section": "",
    "text": "NoteGeopackage\n\n\n\nLe format geopackage permet de stocker plusieurs couches dans un même fichier.\nLa fonction st_layers() permet d’avoir un aperçu des couches présentes dans un fichier geopackage.\n\nst_layers(\"data/lot.gpkg\")\n\n#&gt; Driver: GPKG \n#&gt; Available layers:\n#&gt;     layer_name geometry_type features fields              crs_name\n#&gt; 1     communes Multi Polygon      313     12 RGF93 v1 / Lambert-93\n#&gt; 2 departements Multi Polygon       96      5 RGF93 v1 / Lambert-93\n#&gt; 3  restaurants         Point      694      2 RGF93 v1 / Lambert-93\n#&gt; 4   elevations         Point     5228      1 RGF93 v1 / Lambert-93\n#&gt; 5       routes   Line String     1054      2 RGF93 v1 / Lambert-93",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Import et export</span>"
    ]
  },
  {
    "objectID": "02_import_sf.html#export",
    "href": "02_import_sf.html#export",
    "title": "2  Import et export",
    "section": "2.2 Export",
    "text": "2.2 Export\nLes lignes suivantes exportent l’objet com dans la couche communes du geopackage com.gpkg dans le dossier data.\n\nst_write(obj = com, dsn = \"data/com.gpkg\", layer = \"communes\")\n\n#&gt; Writing layer `communes' to data source `data/com.gpkg' using driver `GPKG'\n#&gt; Writing 313 features with 12 fields and geometry type Multi Polygon.\n\n\n\n\n\n\n\n\nNoteConversion pour le package terra\n\n\n\nLa fonction vect() du package terra permet de transformer un objet sf en objet SpatVector.\n\nlibrary(terra)\n\n#&gt; terra 1.8.70\n\n# conversion\ncom2 &lt;- vect(com)\nclass(com2)\n\n#&gt; [1] \"SpatVector\"\n#&gt; attr(,\"package\")\n#&gt; [1] \"terra\"",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Import et export</span>"
    ]
  },
  {
    "objectID": "02_import_sf.html#exercice",
    "href": "02_import_sf.html#exercice",
    "title": "2  Import et export",
    "section": "Exercice",
    "text": "Exercice\nImportez la couche des restaurants depuis le fichier lot.gpkg dans un objet nommé “resto”.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Import et export</span>"
    ]
  },
  {
    "objectID": "03_affichage_sf.html",
    "href": "03_affichage_sf.html",
    "title": "3  Exploration et affichage",
    "section": "",
    "text": "3.1 Aperçu des variables\nLes objets sf sont des data.frame.\nNous pouvons utiliser les fonctions head() ou summary().\nlibrary(sf)\n\n#&gt; Linking to GEOS 3.13.1, GDAL 3.10.3, PROJ 9.6.0; sf_use_s2() is TRUE\n\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\nhead(com, n = 3)\n\n#&gt; Simple feature collection with 3 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6418606\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;   INSEE_COM  NOM_COM         STATUT POPULATION     AGR_H    AGR_F     IND_H\n#&gt; 1     46001    Albas Commune simple        522  4.978581 0.000000  4.936153\n#&gt; 2     46002   Albiac Commune simple         67  0.000000 9.589041  0.000000\n#&gt; 3     46003 Alvignac Commune simple        706 10.419682 0.000000 10.419682\n#&gt;      IND_F     BTP_H BTP_F     TER_H     TER_F                           geom\n#&gt; 1 0.000000  9.957527     0 44.917145 34.681799 MULTIPOLYGON (((559262 6371...\n#&gt; 2 0.000000  4.794521     0  4.794521  9.589041 MULTIPOLYGON (((605540.7 64...\n#&gt; 3 5.209841 10.419682     0 57.308249 78.147612 MULTIPOLYGON (((593707.7 64...\n\nsummary(com)\n\n#&gt;   INSEE_COM           NOM_COM             STATUT            POPULATION     \n#&gt;  Length:313         Length:313         Length:313         Min.   :   49.0  \n#&gt;  Class :character   Class :character   Class :character   1st Qu.:  172.0  \n#&gt;  Mode  :character   Mode  :character   Mode  :character   Median :  300.0  \n#&gt;                                                           Mean   :  555.7  \n#&gt;                                                           3rd Qu.:  529.0  \n#&gt;                                                           Max.   :19907.0  \n#&gt;      AGR_H            AGR_F            IND_H             IND_F        \n#&gt;  Min.   : 0.000   Min.   : 0.000   Min.   :  0.000   Min.   :  0.000  \n#&gt;  1st Qu.: 0.000   1st Qu.: 0.000   1st Qu.:  4.843   1st Qu.:  0.000  \n#&gt;  Median : 5.000   Median : 0.000   Median :  5.516   Median :  4.943  \n#&gt;  Mean   : 6.935   Mean   : 2.594   Mean   : 16.395   Mean   :  7.635  \n#&gt;  3rd Qu.:10.013   3rd Qu.: 5.000   3rd Qu.: 19.715   3rd Qu.:  9.905  \n#&gt;  Max.   :56.179   Max.   :24.641   Max.   :602.867   Max.   :184.016  \n#&gt;      BTP_H             BTP_F             TER_H             TER_F        \n#&gt;  Min.   :  0.000   Min.   : 0.0000   Min.   :   0.00   Min.   :   0.00  \n#&gt;  1st Qu.:  0.000   1st Qu.: 0.0000   1st Qu.:  10.00   1st Qu.:  15.15  \n#&gt;  Median :  5.000   Median : 0.0000   Median :  20.00   Median :  30.26  \n#&gt;  Mean   :  9.572   Mean   : 0.9723   Mean   :  42.17   Mean   :  60.77  \n#&gt;  3rd Qu.: 10.329   3rd Qu.: 0.0000   3rd Qu.:  44.69   3rd Qu.:  63.95  \n#&gt;  Max.   :203.122   Max.   :16.9238   Max.   :1778.87   Max.   :2397.17  \n#&gt;             geom    \n#&gt;  MULTIPOLYGON :313  \n#&gt;  epsg:2154    :  0  \n#&gt;  +proj=lcc ...:  0  \n#&gt;                     \n#&gt;                     \n#&gt;",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploration et affichage</span>"
    ]
  },
  {
    "objectID": "03_affichage_sf.html#aperçu-des-variables",
    "href": "03_affichage_sf.html#aperçu-des-variables",
    "title": "3  Exploration et affichage",
    "section": "",
    "text": "NoteSupprimer la colonne de géométrie d’un objet sf\n\n\n\nPour transformer un objet sf en simple data.frame (sans géométries), nous pouvons utiliser les fonctions st_set_geometry() ou st_drop_geometry().\n\ncom_df1 &lt;- st_set_geometry(com, NULL)\ncom_df2 &lt;- st_drop_geometry(com)\nidentical(com_df1, com_df2)\n\n#&gt; [1] TRUE\n\nhead(com_df1, n = 3)\n\n#&gt;   INSEE_COM  NOM_COM         STATUT POPULATION     AGR_H    AGR_F     IND_H\n#&gt; 1     46001    Albas Commune simple        522  4.978581 0.000000  4.936153\n#&gt; 2     46002   Albiac Commune simple         67  0.000000 9.589041  0.000000\n#&gt; 3     46003 Alvignac Commune simple        706 10.419682 0.000000 10.419682\n#&gt;      IND_F     BTP_H BTP_F     TER_H     TER_F\n#&gt; 1 0.000000  9.957527     0 44.917145 34.681799\n#&gt; 2 0.000000  4.794521     0  4.794521  9.589041\n#&gt; 3 5.209841 10.419682     0 57.308249 78.147612",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploration et affichage</span>"
    ]
  },
  {
    "objectID": "03_affichage_sf.html#affichage",
    "href": "03_affichage_sf.html#affichage",
    "title": "3  Exploration et affichage",
    "section": "3.2 Affichage",
    "text": "3.2 Affichage\nAperçu des variables avec plot() :\n\nplot(com)\n\n#&gt; Warning: plotting the first 9 out of 12 attributes; use max.plot = 12 to plot\n#&gt; all\n\n\n\n\n\n\n\n\n\nAffichage d’une seule variable :\n\nplot(com[\"POPULATION\"])\n\n\n\n\n\n\n\n\nAffichage de la géométrie seule :\n\nplot(st_geometry(com), col = \"ivory4\", border = \"ivory\")\n\n\n\n\n\n\n\n\nIl est aussi possible d’utiliser le package mapsf (Giraud, 2025) pour afficher les objets sf.\n\nlibrary(mapsf)\nmf_map(com, col = \"ivory4\", border = \"ivory\")",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploration et affichage</span>"
    ]
  },
  {
    "objectID": "03_affichage_sf.html#exercice",
    "href": "03_affichage_sf.html#exercice",
    "title": "3  Exploration et affichage",
    "section": "Exercice",
    "text": "Exercice\nAffichez les communes et les restaurants sur une même carte.\n\n\n\n\nGiraud, T. (2025). mapsf: Thematic Cartography. https://doi.org/10.32614/CRAN.package.mapsf",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploration et affichage</span>"
    ]
  },
  {
    "objectID": "04_projection_sf.html",
    "href": "04_projection_sf.html",
    "title": "4  Les systèmes de coordonnées",
    "section": "",
    "text": "4.1 Consulter le système de coordonnées d’un objet\nLa fonction st_crs() permet de consulter le système de coordonnées utilisé par un objet sf.\nlibrary(sf) \nst_crs(x = com)\n\n#&gt; Coordinate Reference System:\n#&gt;   User input: RGF93 v1 / Lambert-93 \n#&gt;   wkt:\n#&gt; PROJCRS[\"RGF93 v1 / Lambert-93\",\n#&gt;     BASEGEOGCRS[\"RGF93 v1\",\n#&gt;         DATUM[\"Reseau Geodesique Francais 1993 v1\",\n#&gt;             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n#&gt;                 LENGTHUNIT[\"metre\",1]]],\n#&gt;         PRIMEM[\"Greenwich\",0,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#&gt;         ID[\"EPSG\",4171]],\n#&gt;     CONVERSION[\"Lambert-93\",\n#&gt;         METHOD[\"Lambert Conic Conformal (2SP)\",\n#&gt;             ID[\"EPSG\",9802]],\n#&gt;         PARAMETER[\"Latitude of false origin\",46.5,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8821]],\n#&gt;         PARAMETER[\"Longitude of false origin\",3,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8822]],\n#&gt;         PARAMETER[\"Latitude of 1st standard parallel\",49,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8823]],\n#&gt;         PARAMETER[\"Latitude of 2nd standard parallel\",44,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8824]],\n#&gt;         PARAMETER[\"Easting at false origin\",700000,\n#&gt;             LENGTHUNIT[\"metre\",1],\n#&gt;             ID[\"EPSG\",8826]],\n#&gt;         PARAMETER[\"Northing at false origin\",6600000,\n#&gt;             LENGTHUNIT[\"metre\",1],\n#&gt;             ID[\"EPSG\",8827]]],\n#&gt;     CS[Cartesian,2],\n#&gt;         AXIS[\"easting (X)\",east,\n#&gt;             ORDER[1],\n#&gt;             LENGTHUNIT[\"metre\",1]],\n#&gt;         AXIS[\"northing (Y)\",north,\n#&gt;             ORDER[2],\n#&gt;             LENGTHUNIT[\"metre\",1]],\n#&gt;     USAGE[\n#&gt;         SCOPE[\"Engineering survey, topographic mapping.\"],\n#&gt;         AREA[\"France - onshore and offshore, mainland and Corsica (France métropolitaine including Corsica).\"],\n#&gt;         BBOX[41.15,-9.86,51.56,10.38]],\n#&gt;     ID[\"EPSG\",2154]]",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Les systèmes de coordonnées</span>"
    ]
  },
  {
    "objectID": "04_projection_sf.html#modifier-le-système-de-coordonnées-dun-objet",
    "href": "04_projection_sf.html#modifier-le-système-de-coordonnées-dun-objet",
    "title": "4  Les systèmes de coordonnées",
    "section": "4.2 Modifier le système de coordonnées d’un objet",
    "text": "4.2 Modifier le système de coordonnées d’un objet\nLa fonction st_transform() permet de changer le système de coordonnées d’un objet sf, de le reprojeter.\nmf_map(com, expandBB = c(0, .12, 0, 0))\nmf_graticule(x = com)\nmf_title(\"RGF93 / Lambert-93\")\n# changement de projection\ncom_reproj &lt;- st_transform(x = com, crs = \"EPSG:3035\")\n\nmf_map(com_reproj, expandBB = c(0, .12, .0, 0))\nmf_graticule(x = com_reproj)\nmf_title(\"ETRS89-extended / LAEA Europe\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSi l’on souhaite projeter un objet spatial utilisant des coordonnées géographiques (lon/lat), le package crsuggest (Walker, 2022) propose des projections adaptées à l’emprise de l’objet.\nLe site CRS Explorer met à disposition les références de très nombreux systèmes de coordonnées.\n\n\n\n\n\n\n\nWalker, K. (2022). crsuggest: Obtain Suggested Coordinate Reference System Information for Spatial Data. https://doi.org/10.32614/CRAN.package.crsuggest",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Les systèmes de coordonnées</span>"
    ]
  },
  {
    "objectID": "05_selection_attrib_sf.html",
    "href": "05_selection_attrib_sf.html",
    "title": "5  Sélection et jointure attributaire",
    "section": "",
    "text": "5.1 Sélection par attributs\nLes objets sf sont des data.frame, on peut donc sélectionner leur lignes et leur colonnes de la même manière que les data.frame.\n# sélection de lignes\ncom[1:2, ]\n\n#&gt; Simple feature collection with 2 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6410204\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;   INSEE_COM NOM_COM         STATUT POPULATION    AGR_H    AGR_F    IND_H IND_F\n#&gt; 1     46001   Albas Commune simple        522 4.978581 0.000000 4.936153     0\n#&gt; 2     46002  Albiac Commune simple         67 0.000000 9.589041 0.000000     0\n#&gt;      BTP_H BTP_F     TER_H     TER_F                           geom\n#&gt; 1 9.957527     0 44.917145 34.681799 MULTIPOLYGON (((559262 6371...\n#&gt; 2 4.794521     0  4.794521  9.589041 MULTIPOLYGON (((605540.7 64...\n\ncom[com$NOM_COM == \"Gramat\", ]\n\n#&gt; Simple feature collection with 1 feature and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 593605.6 ymin: 6402330 xmax: 602624.6 ymax: 6413784\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;     INSEE_COM NOM_COM         STATUT POPULATION    AGR_H    AGR_F    IND_H\n#&gt; 119     46128  Gramat Commune simple       3468 10.19868 15.29802 122.3842\n#&gt;        IND_F    BTP_H BTP_F    TER_H    TER_F                           geom\n#&gt; 119 107.0862 56.09275     0 260.0664 304.1941 MULTIPOLYGON (((594713.1 64...\n\n# sélection de colonnes\ncom[, \"POPULATION\"]\n\n#&gt; Simple feature collection with 313 features and 1 field\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt; First 10 features:\n#&gt;    POPULATION                           geom\n#&gt; 1         522 MULTIPOLYGON (((559262 6371...\n#&gt; 2          67 MULTIPOLYGON (((605540.7 64...\n#&gt; 3         706 MULTIPOLYGON (((593707.7 64...\n#&gt; 4         219 MULTIPOLYGON (((613211.3 64...\n#&gt; 5         329 MULTIPOLYGON (((556744.9 63...\n#&gt; 6         377 MULTIPOLYGON (((576667.2 64...\n#&gt; 7         988 MULTIPOLYGON (((581404 6370...\n#&gt; 8         203 MULTIPOLYGON (((558216 6389...\n#&gt; 9         642 MULTIPOLYGON (((612729.6 63...\n#&gt; 10        367 MULTIPOLYGON (((581404 6370...\n\ncom[com$NOM_COM == \"Gramat\", 1:4]\n\n#&gt; Simple feature collection with 1 feature and 4 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 593605.6 ymin: 6402330 xmax: 602624.6 ymax: 6413784\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;     INSEE_COM NOM_COM         STATUT POPULATION                           geom\n#&gt; 119     46128  Gramat Commune simple       3468 MULTIPOLYGON (((594713.1 64...",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Sélection et jointure attributaire</span>"
    ]
  },
  {
    "objectID": "05_selection_attrib_sf.html#jointure-attributaire",
    "href": "05_selection_attrib_sf.html#jointure-attributaire",
    "title": "5  Sélection et jointure attributaire",
    "section": "5.2 Jointure attributaire",
    "text": "5.2 Jointure attributaire\nNous pouvons joindre un data.frame à un objet sf en utilisant la fonction merge() et en s’appuyant sur des identifiants communs aux deux objets.\nAttention à l’ordre des arguments, l’objet retourné sera du même type que x. Il n’est pas possible de faire une jointure attributaire en utilisant deux objets sf.\n\n# import de données supplémentaires \ncom_df &lt;- read.csv(file = \"data/com.csv\")\n\n# des identifiants en commun?\nnames(com_df)\n\n#&gt; [1] \"INSEE_COM\" \"ACT\"       \"IND\"       \"SACT\"      \"SACT_IND\"\n\nnames(com)\n\n#&gt;  [1] \"INSEE_COM\"  \"NOM_COM\"    \"STATUT\"     \"POPULATION\" \"AGR_H\"     \n#&gt;  [6] \"AGR_F\"      \"IND_H\"      \"IND_F\"      \"BTP_H\"      \"BTP_F\"     \n#&gt; [11] \"TER_H\"      \"TER_F\"      \"geom\"\n\n# jointure attributaire \ncom_final &lt;- merge(\n  x = com,             # l'objet sf\n  y = com_df,          # le data.frame\n  by.x = \"INSEE_COM\",  # identifiant dans x\n  by.y = \"INSEE_COM\",  # identifiant dans y\n  all.x = TRUE         # conserver toutes les lignes\n)\n\n# Les deux objets ont bien été joints\nhead(com_final, 3)\n\n#&gt; Simple feature collection with 3 features and 16 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6418606\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;   INSEE_COM  NOM_COM         STATUT POPULATION     AGR_H    AGR_F     IND_H\n#&gt; 1     46001    Albas Commune simple        522  4.978581 0.000000  4.936153\n#&gt; 2     46002   Albiac Commune simple         67  0.000000 9.589041  0.000000\n#&gt; 3     46003 Alvignac Commune simple        706 10.419682 0.000000 10.419682\n#&gt;      IND_F     BTP_H BTP_F     TER_H     TER_F       ACT       IND     SACT\n#&gt; 1 0.000000  9.957527     0 44.917145 34.681799  99.47120  4.936153 19.05579\n#&gt; 2 0.000000  4.794521     0  4.794521  9.589041  28.76712  0.000000 42.93600\n#&gt; 3 5.209841 10.419682     0 57.308249 78.147612 171.92475 15.629522 24.35195\n#&gt;   SACT_IND                           geom\n#&gt; 1 4.962393 MULTIPOLYGON (((559262 6371...\n#&gt; 2 0.000000 MULTIPOLYGON (((605540.7 64...\n#&gt; 3 9.090909 MULTIPOLYGON (((593707.7 64...",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Sélection et jointure attributaire</span>"
    ]
  },
  {
    "objectID": "05_selection_attrib_sf.html#exercice",
    "href": "05_selection_attrib_sf.html#exercice",
    "title": "5  Sélection et jointure attributaire",
    "section": "Exercice",
    "text": "Exercice\n\nImporter la couche des communes du département du Lot à partir du fichier geopackage lot.gpkg.\nImporter le fichier com.csv.\nCe jeu de données porte sur les communes du Lot et contient plusieurs variables supplémentaires:\n\nle nombre d’actifs (ACT).\nle nombre d’actifs dans l’industrie (IND)\nla part des actifs dans la population totale (SACT)\nla part des actifs dans l’industrie dans le total des actifs (SACT_IND)\n\nJoindre le jeu de données et la couche des communes.\nSélectionnez les communes du Lot ayant plus de 500 actifs et dont la part des actifs dans la population totale est supérieure à 30%.\nAffichez toutes les communes en gris et les communes sélectionnées en rouge.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Sélection et jointure attributaire</span>"
    ]
  },
  {
    "objectID": "06_selection_jointure_spatiale_sf.html",
    "href": "06_selection_jointure_spatiale_sf.html",
    "title": "6  Sélection et jointure spatiale",
    "section": "",
    "text": "6.1 Sélection spatiale\nLa fonction st_filter() permet d’effectuer des sélections spatiales. L’argument .predicate permet de choisir sur quel critère se fait la sélection en utilisant l’une des fonctions de “prédicat géométrique” (par exemple st_intersects(), st_within(), st_crosses()…).\nNous allons ici sélectionner les routes qui intersectent la commune de Gramat\nroute &lt;- st_read(\"data/lot.gpkg\", layer = \"routes\", quiet = TRUE)\ngramat &lt;-  com[com$NOM_COM == \"Gramat\", ]\n      \nroute_gramat &lt;-  st_filter(x = route, \n                           y = gramat,\n                           .predicate = st_intersects)\n\n# Affichage     \nmf_map(gramat, col = \"wheat\")\nmf_map(route, col = \"grey\", add = TRUE)\nmf_map(route_gramat, col = \"tomato4\", lwd = 2, add = TRUE)",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Sélection et jointure spatiale</span>"
    ]
  },
  {
    "objectID": "06_selection_jointure_spatiale_sf.html#jointure-spatiale",
    "href": "06_selection_jointure_spatiale_sf.html#jointure-spatiale",
    "title": "6  Sélection et jointure spatiale",
    "section": "6.2 Jointure spatiale",
    "text": "6.2 Jointure spatiale\nLa fonction st_join() permet de réaliser des jointures spatiales. Cette fois-ci c’est l’argument join qui utilise une fonction de prédicat géométrique.\n\nroute_gramat &lt;-  st_join(x = route,\n                         y = com[, \"INSEE_COM\"],\n                         join = st_intersects,\n                         left = FALSE)\nroute_gramat\n\n#&gt; Simple feature collection with 1247 features and 3 fields\n#&gt; Geometry type: LINESTRING\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 587147.6 ymin: 6394844 xmax: 608194.7 ymax: 6420006\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt; First 10 features:\n#&gt;     ID      CLASS_ADM INSEE_COM                           geom\n#&gt; 1    1 Départementale     46240 LINESTRING (590557.5 641181...\n#&gt; 2    2 Départementale     46240 LINESTRING (593733.2 641429...\n#&gt; 3    3 Départementale     46240 LINESTRING (590665 6412381,...\n#&gt; 4    4 Départementale     46128 LINESTRING (598940.9 640909...\n#&gt; 5    5 Départementale     46104 LINESTRING (603201.9 640181...\n#&gt; 6    6     Sans objet     46235 LINESTRING (598162.3 640108...\n#&gt; 7    7 Départementale     46090 LINESTRING (598887.3 639763...\n#&gt; 7.1  7 Départementale     46138 LINESTRING (598887.3 639763...\n#&gt; 7.2  7 Départementale     46233 LINESTRING (598887.3 639763...\n#&gt; 8    8 Départementale     46090 LINESTRING (601184.3 639697...",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Sélection et jointure spatiale</span>"
    ]
  },
  {
    "objectID": "06_selection_jointure_spatiale_sf.html#exercice",
    "href": "06_selection_jointure_spatiale_sf.html#exercice",
    "title": "6  Sélection et jointure spatiale",
    "section": "Exercice",
    "text": "Exercice\n\nImportez la couche des communes et celle des restaurants du Lot.\nRéaliser une jointure spatiale pour connaître pour chaque restaurant le nom et l’identifiant de la commune dans laquelle il se trouve.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Sélection et jointure spatiale</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html",
    "href": "07_operation_geom_sf.html",
    "title": "7  Opérations sur les géométries",
    "section": "",
    "text": "7.1 Extraire des centroïdes\ncom_c &lt;- st_centroid(com)\n\n#&gt; Warning: st_centroid assumes attributes are constant over geometries\n\nmf_map(com)\nmf_map(com_c, add = TRUE, cex = 1.2, col = \"red\", pch = 20)",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#agréger-des-polygones",
    "href": "07_operation_geom_sf.html#agréger-des-polygones",
    "title": "7  Opérations sur les géométries",
    "section": "7.2 Agréger des polygones",
    "text": "7.2 Agréger des polygones\n\ndep_46 &lt;- st_union(com)\n\nmf_map(com)\nmf_map(dep_46, col = NA, border = \"red\", lwd = 2, add = TRUE)",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#agréger-des-polygones-en-fonction-dune-variable",
    "href": "07_operation_geom_sf.html#agréger-des-polygones-en-fonction-dune-variable",
    "title": "7  Opérations sur les géométries",
    "section": "7.3 Agréger des polygones en fonction d’une variable",
    "text": "7.3 Agréger des polygones en fonction d’une variable\n\nAvec la fonction tapply()\n\n\n# variable servant à agréger les polygones\ni &lt;- com$STATUT \n\ncom_u &lt;- st_sf(\n  STATUT     = tapply(X = com$STATUT     , INDEX = i, FUN = head, 1),\n  POPULATION = tapply(X = com$POPULATION , INDEX = i, FUN = sum), \n  geometry   = tapply(X = com            , INDEX = i, FUN = st_union), \n  crs        = st_crs(com)\n) \n\n\n\n\n\n\n\nNoteExplication de la méthode d’agrégation\n\n\n\n\n\ntapply(X, INDEX, FUN) permet d’aggréger une variable en fonction d’une autre.\nIl faut indiquer la variable à agréger X, la variable servant à agréger INDEX et la manière d’agréger (la fonction d’agrégation) FUN.\nIci par exemple nous calculons la somme des population des communes en fonction de leur statut :\n\ntapply(X = com$POPULATION, INDEX = com$STATUT, FUN = sum)\n\n#&gt;  Commune simple      Préfecture Sous-préfecture \n#&gt;          140259           19907           13763\n\n\ntapply() fonctionne également avec les objets sf et sfc:\n\nst_sf(geometry = st_sfc(tapply(com, com$STATUT, st_union)))\n\n#&gt; Simple feature collection with 3 features and 0 fields\n#&gt; Geometry type: GEOMETRY\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; CRS:           NA\n#&gt;                         geometry\n#&gt; 1 POLYGON ((554732.7 6356281,...\n#&gt; 2 MULTIPOLYGON (((580994.5 63...\n#&gt; 3 MULTIPOLYGON (((626296.4 63...\n\n\nNous pouvons ensuite combiner plusieurs appels tapply() à l’interieur d’un appel à st_sf() en ajoutant également les informations sur le système de coordonnées.\n\nst_sf(\n  STATUT     = tapply(com$STATUT    , com$STATUT, head, 1), # identifiants\n  POPULATION = tapply(com$POPULATION, com$STATUT, sum),     # somme des populations\n  geometry   = tapply(com           , com$STATUT, st_union),# union des géométries \n  crs        = st_crs(com)                                  # information sur le CRS\n) \n\n#&gt; Simple feature collection with 3 features and 2 fields\n#&gt; Geometry type: GEOMETRY\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;            STATUT POPULATION                       geometry\n#&gt; 1  Commune simple     140259 POLYGON ((554732.7 6356281,...\n#&gt; 2      Préfecture      19907 MULTIPOLYGON (((580994.5 63...\n#&gt; 3 Sous-préfecture      13763 MULTIPOLYGON (((626296.4 63...\n\n\n\n\n\n\n\n\n\n\n\nL’avantage de cette solution est qu’elle permet d’agréger les variables attributaires avec des fonctions d’agrégation différentes. Nous pouvons par exemple utiliser la somme pour une population (un stock) et la moyenne pour un taux de chômage (un ratio).\n\n\n\n\nAvec la fonction aggregate()\n\n\ncom_u &lt;- aggregate(\n  x = com[\"POPULATION\"], \n  by = list(STATUT = com$STATUT), \n  FUN = sum\n)\n\n\n\n\n\n\n\nCette solution ne permettra pas d’agréger les variables attributaires avec des fonctions d’agrégation différentes. Nous devons donc choisir avec précaution en amont les variables que l’on souhaite agréger et leur fonction d’agrégation.\n\n\n\n\nAvec la bibliothèque dplyr\n\n\nlibrary(dplyr)\n\n#&gt; \n#&gt; Attaching package: 'dplyr'\n\n\n#&gt; The following objects are masked from 'package:stats':\n#&gt; \n#&gt;     filter, lag\n\n\n#&gt; The following objects are masked from 'package:base':\n#&gt; \n#&gt;     intersect, setdiff, setequal, union\n\ncom_u &lt;- com |&gt;\n  group_by(STATUT) |&gt;\n  summarise(POPULATION = sum(POPULATION))",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#construire-une-zone-tampon",
    "href": "07_operation_geom_sf.html#construire-une-zone-tampon",
    "title": "7  Opérations sur les géométries",
    "section": "7.4 Construire une zone tampon",
    "text": "7.4 Construire une zone tampon\nLa fonction st_buffer() permet de construire des zones tampons. La distance est exprimée en unité de la projection utilisée (st_crs(x)$units).\n\ngramat &lt;- com[com$NOM_COM == \"Gramat\", ]\n\ngramat_b &lt;- st_buffer(x = gramat, dist = 5000)\n\nmf_map(gramat_b, col = \"wheat\", lwd = 2, border = \"red\")\nmf_map(gramat, add = TRUE, lwd = 2)",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#réaliser-une-intersection",
    "href": "07_operation_geom_sf.html#réaliser-une-intersection",
    "title": "7  Opérations sur les géométries",
    "section": "7.5 Réaliser une intersection",
    "text": "7.5 Réaliser une intersection\nEn utilisant la fonction st_intersection(), on peut découper une couche par une autre.\n\n# création d'une zone tampon autour du centroide de la commune de Gramat\nzone &lt;- st_geometry(gramat) |&gt; \n  st_centroid() |&gt; \n  st_buffer(10000)\n\nmf_map(com)\nmf_map(zone, border = \"red\", col = NA, lwd = 2, add = TRUE)\n\n\n\n\n\n\n\ncom_z &lt;- st_intersection(x = com, y = zone)\n\n#&gt; Warning: attribute variables are assumed to be spatially constant throughout\n#&gt; all geometries\n\nmf_map(com)\nmf_map(com_z, col = \"red\", border = \"green\", add = TRUE)\n\n\n\n\n\n\n\nmf_map(com_z)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDans cet exemple nous avons utilisé les pipes (|&gt;). Les pipes permettent d’enchaîner une suite d’instructions.\nPlus d’infos : Data first, nom d’un pipe.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#créer-une-grille-régulière",
    "href": "07_operation_geom_sf.html#créer-une-grille-régulière",
    "title": "7  Opérations sur les géométries",
    "section": "7.6 Créer une grille régulière",
    "text": "7.6 Créer une grille régulière\nLa fonction st_make_grid() permet de créer une grille régulière. La fonction produit un objet sfc, il faut ensuite utiliser la fonction st_sf() pour transformer cet objet sfc en objet sf. Lors de cette transformation nous rajoutons ici une colonne d’identifiants uniques.\n\n# Création de la grille\ngrid &lt;- st_make_grid(x = com, cellsize = 5000)\n\n# Ajout d'un identifiant unique\ngrid &lt;- st_sf(ID = 1:length(grid), geom = grid)\n\nmf_map(grid, border = \"white\")\nmf_map(com, col = NA, add = TRUE)",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#compter-des-points-dans-un-polygone",
    "href": "07_operation_geom_sf.html#compter-des-points-dans-un-polygone",
    "title": "7  Opérations sur les géométries",
    "section": "7.7 Compter des points dans un polygone",
    "text": "7.7 Compter des points dans un polygone\nSélection des carreaux de la grille qui intersectent le département avec st_filter().\n\ngrid &lt;- st_filter(grid, dep_46, .predicate = st_intersects)\n\n# Import d'une couche géographique ponctuelle des restaurants du Lot\nrestaurant &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\n\nmf_map(grid, border = \"white\")\nmf_map(restaurant, pch = 20, cex = .5, add = TRUE)\n\n\n\n\n\n\n\n\nNous utilisons ensuite la fonction st_intersects(..., sparse = TRUE) qui nous permettra d’avoir pour chaque élément de l’objet grid la liste des éléments (via leurs indexes) de l’objet restaurant qui se trouvent à l’intérieur.\n\ninter &lt;- st_intersects(grid, restaurant, sparse = TRUE)\n\nlength(inter) == nrow(grid)\n\n#&gt; [1] TRUE\n\n\nPour compter le nombre de restaurants il suffit donc de reporter la longueur de chacun des éléments de cette liste.\n\ngrid$nb_restaurant &lt;- lengths(inter)\n\nmf_map(grid)\nmf_map(grid, var = \"nb_restaurant\", type = \"prop\")\n\n#&gt; 94 '0' values are not plotted on the map.",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#agréger-les-valeurs-de-points-dans-des-polygones",
    "href": "07_operation_geom_sf.html#agréger-les-valeurs-de-points-dans-des-polygones",
    "title": "7  Opérations sur les géométries",
    "section": "7.8 Agréger les valeurs de points dans des polygones",
    "text": "7.8 Agréger les valeurs de points dans des polygones\nIci nous voulons résumer l’information contenue dans une couche de points dans des polygones. Nous voulons connaître l’altitude minimale et maximale de chaque communes.\nNous commencons par importer une couche de points d’altitude, la couche elevations du fichier lot.gpkg.\n\nelev &lt;- st_read(\"data/lot.gpkg\", \"elevations\", quiet = TRUE)\n\nmf_map(elev, \"elevation\", \"choro\", \n       breaks = c(80, seq(100, 700, by = 100), 742),\n       pal = hcl.colors(8, \"Terrain2\"), \n       pch = 21, leg_pos = \"topleft\", cex = .75)\n\n\n\n\n\n\n\n\nL’objectif est d’agréger les valeurs de ces points (les altitudes contenues dans le champ elevation) dans les communes du Lot.\nEn utilisant la fonction st_join() nous pouvons récupérer les attributs des communes dans lesquelles se trouvent les points.\n\ninter &lt;- st_join(x = elev, y = com[, \"INSEE_COM\"])\ninter\n\n#&gt; Simple feature collection with 5228 features and 2 fields\n#&gt; Geometry type: POINT\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 540333.3 ymin: 6347372 xmax: 637333.3 ymax: 6439372\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt; First 10 features:\n#&gt;    elevation INSEE_COM                     geom\n#&gt; 1   308.8546     46083 POINT (584333.3 6439372)\n#&gt; 2   304.6855     46083 POINT (582333.3 6438372)\n#&gt; 3   290.6638     46083 POINT (583333.3 6438372)\n#&gt; 4   295.0353     46083 POINT (584333.3 6438372)\n#&gt; 5   297.6773     46083 POINT (587333.3 6438372)\n#&gt; 6   257.7393     46083 POINT (588333.3 6438372)\n#&gt; 7   310.1883     46083 POINT (580333.3 6437372)\n#&gt; 8   305.0571     46083 POINT (581333.3 6437372)\n#&gt; 9   298.5876     46083 POINT (582333.3 6437372)\n#&gt; 10  287.6990     46083 POINT (583333.3 6437372)\n\n\nNous pouvons ensuite utiliser la fonction aggregate() pour agréger les altitudes par communes, d’abord l’altitude minimale, puis l’altitude maximale.\n\n# x   : la variable que l'on veut agréger\n# by  : la variable qui servira à agréger \n# FUN : la fonction à utiliser lors de l'agrégation\nalti_min &lt;- aggregate(x   = list(alt_min   = inter$elevation),    \n                      by  = list(INSEE_COM = inter$INSEE_COM),\n                      FUN = \"min\")\n\nalti_max &lt;- aggregate(x   = list(alt_max   = inter$elevation),\n                      by  = list(INSEE_COM = inter$INSEE_COM),\n                      FUN = \"max\")\n\nhead(alti_max, n = 3)\n\n#&gt;   INSEE_COM  alt_max\n#&gt; 1     46001 302.4913\n#&gt; 2     46002 393.9218\n#&gt; 3     46003 376.6632\n\n\nOn peut ensuite combiner ces résultats à la couche des communes (avec la fonction merge()).\n\ncom &lt;- merge(com, alti_min, by = \"INSEE_COM\", all.x = TRUE)\ncom &lt;- merge(com, alti_max, by = \"INSEE_COM\", all.x = TRUE)\nhead(com, n = 3)\n\n#&gt; Simple feature collection with 3 features and 14 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6418606\n#&gt; Projected CRS: RGF93 v1 / Lambert-93\n#&gt;   INSEE_COM  NOM_COM         STATUT POPULATION     AGR_H    AGR_F     IND_H\n#&gt; 1     46001    Albas Commune simple        522  4.978581 0.000000  4.936153\n#&gt; 2     46002   Albiac Commune simple         67  0.000000 9.589041  0.000000\n#&gt; 3     46003 Alvignac Commune simple        706 10.419682 0.000000 10.419682\n#&gt;      IND_F     BTP_H BTP_F     TER_H     TER_F  alt_min  alt_max\n#&gt; 1 0.000000  9.957527     0 44.917145 34.681799 109.5772 302.4913\n#&gt; 2 0.000000  4.794521     0  4.794521  9.589041 363.4579 393.9218\n#&gt; 3 5.209841 10.419682     0 57.308249 78.147612 258.8378 376.6632\n#&gt;                             geom\n#&gt; 1 MULTIPOLYGON (((559262 6371...\n#&gt; 2 MULTIPOLYGON (((605540.7 64...\n#&gt; 3 MULTIPOLYGON (((593707.7 64...\n\n\nbks &lt;- c(80, seq(100, 700, by = 100), 742)\ncols &lt;- hcl.colors(8, \"Terrain2\")\n\nmf_map(com, \"alt_min\", \"choro\", breaks = bks, pal = cols)\nmf_map(com, \"alt_max\", \"choro\", breaks = bks, pal = cols)",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#simplifier-des-géométries",
    "href": "07_operation_geom_sf.html#simplifier-des-géométries",
    "title": "7  Opérations sur les géométries",
    "section": "7.9 Simplifier des géométries",
    "text": "7.9 Simplifier des géométries\n Le package rmapshaper (Teucher et Russell, 2023) s’appuie sur la bibliothèque JavaScript Mapshaper (Bloch, 2025) pour proposer plusieurs méthodes de simplification des géométries qui respectent la topologie.\nL’argument keep permet d’indiquer le niveau de simplification. L’argument keep_shapes permet de conserver tous les polygones quand le niveau de simplification est élevé.\nlibrary(\"rmapshaper\")\ncom_simp1 &lt;- ms_simplify(com, keep = 0.01 , keep_shapes = TRUE)\ncom_simp2 &lt;- ms_simplify(com, keep = 0.001, keep_shapes = TRUE)\nmf_map(com)\nmf_map(com_simp1)\nmf_map(com_simp2)",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "07_operation_geom_sf.html#exercice",
    "href": "07_operation_geom_sf.html#exercice",
    "title": "7  Opérations sur les géométries",
    "section": "Exercice",
    "text": "Exercice\n\nCalculez le nombre de restaurants par commune.\nQuelles communes ont plus de 10 restaurants et moins de 1000 habitants ?\nCréez une carte où vous afficherez toutes les communes en gris et les communes sélectionnées plus haut en rouge.\n\n\n\n\n\nBloch, M. (2025). Mapshaper: Tools for editing Shapefile, GeoJSON, TopoJSON and CSV files JavaScript libary. https://github.com/mbloch/mapshaper\n\n\nTeucher, A. et Russell, K. (2023). rmapshaper: Client for ’mapshaper’ for ’Geospatial’ Operations. https://doi.org/10.32614/CRAN.package.rmapshaper",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Opérations sur les géométries</span>"
    ]
  },
  {
    "objectID": "08_mesures_sf.html",
    "href": "08_mesures_sf.html",
    "title": "8  Mesures",
    "section": "",
    "text": "8.1 Créer une matrice de distances\nLa fonction st_distance() permet de calculer une matrice de distance entre deux couches de points.\nSi le système de projection du jeu de données est renseigné, les distances sont exprimées dans l’unité de mesure de la projection (le plus souvent en mètres).\nlibrary(sf)\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE, agr = \"constant\")\n# transformation de la couche com en couche de points\ncom_c &lt;- st_centroid(com)\nmat &lt;- st_distance(x = com_c, y = com_c)\nmat[1:5,1:5]\n\n#&gt; Units: [m]\n#&gt;           [,1]     [,2]     [,3]     [,4]      [,5]\n#&gt; [1,]     0.000 56784.77 54353.94 61166.42  3790.688\n#&gt; [2,] 56784.770     0.00 12454.29  7146.11 57288.103\n#&gt; [3,] 54353.942 12454.29     0.00 19388.52 54030.811\n#&gt; [4,] 61166.418  7146.11 19388.52     0.00 62016.141\n#&gt; [5,]  3790.688 57288.10 54030.81 62016.14     0.000",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mesures</span>"
    ]
  },
  {
    "objectID": "08_mesures_sf.html#calcul-de-superficies",
    "href": "08_mesures_sf.html#calcul-de-superficies",
    "title": "8  Mesures",
    "section": "8.2 Calcul de superficies",
    "text": "8.2 Calcul de superficies\nLa fonction st_area() permet de calculer des superficies.\n\nst_area(com[1:5, ])\n\n#&gt; Units: [m^2]\n#&gt; [1] 21721665  3813205 13024216  9993074  5540367",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mesures</span>"
    ]
  },
  {
    "objectID": "08_mesures_sf.html#convertir-des-unités",
    "href": "08_mesures_sf.html#convertir-des-unités",
    "title": "8  Mesures",
    "section": "8.3 Convertir des unités",
    "text": "8.3 Convertir des unités\nLe package units (Pebesma et al., 2016) permet de définir et convertir facilement des unités de mesure.\nLe package peut se révéler assez utile quand nous manipulons différentes unités de mesures régulièrement.\n\nlibrary(units)\n\n#&gt; udunits database from /usr/share/xml/udunits/udunits2.xml\n\ndistances &lt;- c(1, 2, 3, 5, 0.5)\nsurfaces &lt;- c(500, 1000, 10000, 20000)\n\n# définition des unités de mesure initiales\ndistances &lt;- set_units(distances, \"km\")\ndistances\n\n#&gt; Units: [km]\n#&gt; [1] 1.0 2.0 3.0 5.0 0.5\n\nsurfaces &lt;- set_units(surfaces, \"m2\")\nsurfaces\n\n#&gt; Units: [m^2]\n#&gt; [1]   500  1000 10000 20000\n\n# transformation des unités de mesure\ndistances &lt;- set_units(distances, \"m\")\ndistances\n\n#&gt; Units: [m]\n#&gt; [1] 1000 2000 3000 5000  500\n\nsurfaces &lt;- set_units(surfaces, \"ha\")\nsurfaces\n\n#&gt; Units: [ha]\n#&gt; [1] 0.05 0.10 1.00 2.00\n\n## Suppression des unités\ndistances &lt;- set_units(distances, NULL)\ndistances\n\n#&gt; [1] 1000 2000 3000 5000  500\n\nsurfaces &lt;- set_units(surfaces, NULL)\nsurfaces\n\n#&gt; [1] 0.05 0.10 1.00 2.00\n\n\n\n\n\n\nPebesma, E., Mailund, T. et Hiebert, J. (2016). Measurement Units in R. R Journal, 8(2), 486‑494. https://doi.org/10.32614/RJ-2016-061",
    "crumbs": [
      "**Les données vectorielles : le package sf**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Mesures</span>"
    ]
  },
  {
    "objectID": "09_package_terra.html",
    "href": "09_package_terra.html",
    "title": "9  Le package terra",
    "section": "",
    "text": "9.1 Présentation\nL’objectif du package terra (Hijmans, 2025) est de proposer des méthodes de traitement et d’analyse de données raster. Ce package est très similaire au package raster, mais il propose plus de fonctionnalités. Il est plus rapide et plus facile à utiliser.\nCe chapitre est largement inspiré de deux présentations (Madelin, 2021; Nowosad, 2021) réalisées dans le cadre de l’école thématique “Science de l’Information Géographique Reproductibles 2021” (SIGR2021).",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Le package terra</span>"
    ]
  },
  {
    "objectID": "09_package_terra.html#présentation",
    "href": "09_package_terra.html#présentation",
    "title": "9  Le package terra",
    "section": "",
    "text": "NoteSite web du package terra :\n\n\n\nSpatial Data Science with R and “terra”",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Le package terra</span>"
    ]
  },
  {
    "objectID": "09_package_terra.html#format-des-objets-spatraster",
    "href": "09_package_terra.html#format-des-objets-spatraster",
    "title": "9  Le package terra",
    "section": "9.2 Format des objets SpatRaster",
    "text": "9.2 Format des objets SpatRaster\nLe package terra (Hijmans, 2025) permet de gérer des données vectorielles et raster. Pour manipuler ces données spatiales, terra les stockent dans des objets de type SpatVector et SpatRaster. Dans ce document, nous nous focalisons sur la manipulation de données raster (SpatRaster) à partir de fonctions proposées par ce package.\nUn objet SpatRaster représente des données matricielles, en une ou plusieurs couches (variables). Cet objet stocke également un certain nombre de paramètres fondamentaux qui le décrivent (nombre de colonnes, de lignes, étendue spatiale, système de référence des coordonnées…).\n\n\n\nRacine (2016)\n\n\n\n\n\n\nHijmans, R. J. (2025). terra: Spatial Data Analysis. https://doi.org/10.32614/CRAN.package.terra\n\n\nMadelin, M. (2021). Analyse d’images raster (et télédétection). https://mmadelin.github.io/sigr2021/SIGR2021_raster_MM.html.\n\n\nNowosad, J. (2021). Image processing and all things raster. https://nowosad.github.io/SIGR2021/workshop2/workshop2.html.\n\n\nRacine, E. B. (2016). The Visual Raster Cheat Sheet. https://rpubs.com/etiennebr/visualraster.",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Le package terra</span>"
    ]
  },
  {
    "objectID": "10_import_terra.html",
    "href": "10_import_terra.html",
    "title": "10  Import et export",
    "section": "",
    "text": "10.1 Import\nLe package terra permet d’importer et d’exporter des fichiers raster. Il repose sur la bibliothèque GDAL (GDAL/OGR contributors, 2025) qui permet de lire et de traiter un très grand nombre de format d’images géographiques.\nLa fonction rast() permet de créer et/ou d’importer des données raster. Les lignes suivantes importent le fichier raster elevation.tif (Tagged Image File Format) au format d’objet SpatRaster.\nelev &lt;- rast(\"data/elevation.tif\") \nelev\n\n#&gt; class       : SpatRaster \n#&gt; size        : 987, 1300, 1  (nrow, ncol, nlyr)\n#&gt; resolution  : 0.0002972796, 0.0002972796  (x, y)\n#&gt; extent      : 1.245749, 1.632213, 44.30927, 44.60269  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#&gt; source      : elevation.tif \n#&gt; name        : altitude \n#&gt; min value   :       91 \n#&gt; max value   :      421",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Import et export</span>"
    ]
  },
  {
    "objectID": "10_import_terra.html#export",
    "href": "10_import_terra.html#export",
    "title": "10  Import et export",
    "section": "10.2 Export",
    "text": "10.2 Export\nLa fonction writeRaster() permet d’enregistrer un objet SpatRaster sur votre machine, dans le format de votre choix.\n\nwriteRaster(x = elev, filename = \"data/new_elevation_Lot.tif\")\n\n\n\n\n\n\n\nNoteConversion pour le package sf\n\n\n\nLe package terra permet de manipuler des objets vectoriels en utilisant des objets de type SpatVector.\nLa fonction st_as_sf() du package sf permet de transformer un objet SpatVector en objet sf.\n\n# adresse du fichier d'exemple\nf &lt;- system.file(\"ex/lux.shp\", package=\"terra\")\n# import au format SpatVector\nv &lt;- vect(f)\nlibrary(sf)\n# conversion\nv2 &lt;- st_as_sf(v)\nclass(v2)\n\n#&gt; [1] \"sf\"         \"data.frame\"\n\n\n\n\n\n\n\n\nGDAL/OGR contributors. (2025). GDAL/OGR Geospatial Data Abstraction software Library. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.5884351",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Import et export</span>"
    ]
  },
  {
    "objectID": "11_affichage_terra.html",
    "href": "11_affichage_terra.html",
    "title": "11  Affichage",
    "section": "",
    "text": "La fonction plot() permet d’afficher un objet SpatRaster.\n\nlibrary(terra)\n\n#&gt; terra 1.8.70\n\nelev &lt;- rast(\"data/elevation.tif\") \nplot(elev)\n\n\n\n\n\n\n\n\nUn raster contient toujours des données numériques, mais il peut aussi bien s’agir de données quantitatives que de données qualitatives (catégorielles) codées numériquement.\nPrécisez le type de données stockées avec l’argument type (type = \"continuous\" par défaut), pour les afficher correctement.\nImport et affichage d’un raster contenant des données catégorielles : CORINE Land Cover 2018 (type d’occupation du sol) avec une résolution de 100m. Ces données ont été récupérées sur le site de Copernicus, le programme européen de surveillance de la Terre qui collecte et met à disposition des données issues de ses propres satellites (Sentinelles) d’observation. Une extraction centrée sur la commune de Cahors a ensuite été réalisée.\n\nclc &lt;- rast(\"data/clc_2018.tif\")\n\n# Affichage\nplot(clc, type=\"classes\")\n\n\n\n\n\n\n\n\nPour afficher les intitulés réels des types d’occupation du sol, ainsi que les couleurs officielles de la nomenclature CORINE Land Cover (consultables ici), vous pouvez procéder de la manière suivante :\n\nintitule_poste &lt;- c(\n  \"Tissu urbain continu\", \"Tissu urbain discontinu\",\n  \"Zones industrielles ou commerciales et installations publiques\",\n  \"Réseaux routier et ferroviaire et espaces associés\", \n  \"Aéroports\",\"Extraction de matériaux\", \n  \"Equipements sportifs et de loisirs\", \n  \"Terres arables hors périmètres d'irrigation\", \"Vignobles\", \n  \"Vergers et petits fruits\", \n  \"Prairies et autres surfaces toujours en herbe à usage agricole\", \n  \"Systèmes culturaux et parcellaires complexes\", \n  \"Surfaces essentiellement agricoles (interrompues par espaces nat.)\", \n  \"Forêts de feuillus\", \"Forêts de conifères\", \"Forêts mélangées\",\n  \"Pelouses et pâturages naturels\", \n  \"Landes et broussailles\", \"Végétation sclérophylle\", \n  \"Forêt et végétation arbustive en mutation\", \n  \"Cours et voies d'eau\", \"Plans d'eau\"\n)\ncouleur_off &lt;- c(\"#E6004D\", \"#FF0000\", \"#CC4DF2\", \"#CC0000\", \"#E6CCE6\", \"#A600CC\", \n                 \"#FFE6FF\", \"#FFFFA8\", \"#E68000\", \"#F2A64D\", \"#E6E64D\", \"#FFE64D\", \n                 \"#E6CC4D\", \"#80FF00\", \"#00A600\", \"#4DFF00\", \"#CCF24D\", \"#A6FF80\", \n                 \"#A6E64D\", \"#A6F200\", \"#00CCF2\", \"#80F2E6\")\nplot(clc, \n     type = \"classes\", \n     levels = intitule_poste,\n     col = couleur_off, \n     plg = list(cex = 0.7),\n     mar = c(3.1, 1.1, 1.1, 10)\n     )",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Affichage</span>"
    ]
  },
  {
    "objectID": "12_modif_zone_terra.html",
    "href": "12_modif_zone_terra.html",
    "title": "12  Modifications de la zone d’étude",
    "section": "",
    "text": "12.1 Projections\nPour modifier le système de projection d’un raster, nous pouvons utiliser la fonction project(). Il est alors nécessaire de fournir un modèle et d’indiquer la méthode d’estimation des nouvelles valeurs des cellules.\nLe modèle est un nouveau raster sur lequel aligner/projeter les données. Pour construire un modèle, nous utilisons dans un premier temps la fonction project(x, crs). Cette fonction va produire un raster avec une résolution choisie automatiquement. Nous utilisons ensuite la fonction res() (ou dim()) pour ajuster la résolution de ce raster modèle (voir ?project). La fonction project() peut ensuite être réutilisée pour projeter les valeurs dans le modèle, en précisant la méthode d’estimation à utiliser.\nQuatre méthodes d’estimation sont disponibles :\nPour sauvegarder les rasters reprojetés :\nwriteRaster(elev, filename = \"data/elev.tif\")\nwriteRaster(clc, filename = \"data/clc.tif\")",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modifications de la zone d'étude</span>"
    ]
  },
  {
    "objectID": "12_modif_zone_terra.html#sec-proj",
    "href": "12_modif_zone_terra.html#sec-proj",
    "title": "12  Modifications de la zone d’étude",
    "section": "",
    "text": "near : plus proche voisin. Méthode rapide et par défaut pour les données qualitatives;\n\nbilinear : interpolation bilinéaire. Méthode par défaut pour les données quantitatives;\n\ncubic : interpolation cubique;\n\ncubicspline : interpolation cubique spline.\n\nlibrary(terra)\n\n#&gt; terra 1.8.70\n\nelev_raw &lt;- rast(\"data/elevation.tif\") \nclc_raw &lt;- rast(\"data/clc_2018.tif\")\n\n# Création d'un modèle de raster en 2154\nmodel_proj &lt;- project(x = elev_raw, y = \"EPSG:2154\")\n\n# Ajustement de la résolution du modèle (100 m)\nres(model_proj) &lt;- 100\n\n# Projection dans le modèle\nelev &lt;- project(x = elev_raw, y = model_proj, method = \"bilinear\")\nclc &lt;- project(x = clc_raw, y = model_proj, method = \"near\")\n\nplot(elev, main = \"Altitudes - RGF93 v1 / Lambert-93\" )\nplot(clc, type = \"classes\",  main = \"CLC - RGF93 v1 / Lambert-93\")",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modifications de la zone d'étude</span>"
    ]
  },
  {
    "objectID": "12_modif_zone_terra.html#sec-crop",
    "href": "12_modif_zone_terra.html#sec-crop",
    "title": "12  Modifications de la zone d’étude",
    "section": "12.2 Crop",
    "text": "12.2 Crop\nLe découpage d’un raster en fonction de l’étendue d’un autre objet, SpatVector ou SpatRaster, est réalisable avec la fonction crop().\n\n\n\n\n\n\nRacine (2016)\n\n\n\n\n\n\n\n\nImport de données vectorielles (découpages communaux) avec la fonction vect du package terra. Ces données seront stockées dans un objet SpatVector.\n\ncommune &lt;- vect(\"data/lot.gpkg\", layer=\"communes\")\n\nExtraction des limites communales de Cahors (code INSEE = 46042).\n\ncahors &lt;- subset(commune, commune$INSEE_COM == \"46042\") \n\nPour utiliser la fonction crop(), les deux couches de données doivent être dans la même projection.\n\ncrop_cahors &lt;- crop(elev, cahors)\n\nplot(crop_cahors)\nplot(cahors, add = TRUE)",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modifications de la zone d'étude</span>"
    ]
  },
  {
    "objectID": "12_modif_zone_terra.html#mask",
    "href": "12_modif_zone_terra.html#mask",
    "title": "12  Modifications de la zone d’étude",
    "section": "12.3 Mask",
    "text": "12.3 Mask\nPour afficher uniquement les valeurs d’un raster contenu dans un polygone, utilisez la fonction mask().\nCréation d’un masque sur le raster crop_cahors en fonction des limites communales (polygone) de cahors :\n\nmask_cahors &lt;- mask(crop_cahors, cahors)\n\nplot(mask_cahors)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteMask vs. Crop\n\n\n\nMasquer un raster (mask) signifie remplacer les valeurs de pixels en dehors d’une zone d’intérêt en NA. Les dimensions du raster ne sont pas modifiées.\nRecadrer un raster (crop) signifie supprimer les lignes et/ou les colonnes qui se trouvent en dehors d’une zone d’intéret. Les dimensions du raster sont modifiées.",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modifications de la zone d'étude</span>"
    ]
  },
  {
    "objectID": "12_modif_zone_terra.html#agrégation-désagrégation",
    "href": "12_modif_zone_terra.html#agrégation-désagrégation",
    "title": "12  Modifications de la zone d’étude",
    "section": "12.4 Agrégation & désagrégation",
    "text": "12.4 Agrégation & désagrégation\n\n\n\n \n\n\n\n\n\n \n\n\n\n\n\n\n\nRacine (2016)\n\n\n\n\n\n\n\n\nLe ré-échantillonnage d’un raster dans une résolution différente se fait en plusieurs étapes.\n\nAfficher la résolution d’un raster avec la fonction res().\n\n\nres(elev) \n\n#&gt; [1] 100 100\n\n\n\nCréer une grille de même étendue, puis en diminuer la résolution spatiale (plus grosses cellules).\n\n\nelev_lower_model  &lt;- elev\n\n# Tailles des cellules = 1000 mètres\nres(elev_lower_model) &lt;- 1000\n\nelev_lower_model\n\n#&gt; class       : SpatRaster \n#&gt; size        : 33, 31, 1  (nrow, ncol, nlyr)\n#&gt; resolution  : 1000, 1000  (x, y)\n#&gt; extent      : 560073.1, 591073.1, 6357644, 6390644  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154)\n\n\n\nLa fonction resample() permet de ré-échantillonner les valeurs de départ dans la nouvelle résolution spatiale. Plusieurs méthodes de ré-échantillonnage sont disponibles (voir Section 12.1).\n\n\nelev_lower &lt;- resample(x = elev,\n                       y = elev_lower_model, \n                       method = \"bilinear\") \n\nplot(elev_lower, \n     main = \"cellsize = 1000m - ré-échantillonnage bilinéaire\")",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modifications de la zone d'étude</span>"
    ]
  },
  {
    "objectID": "12_modif_zone_terra.html#fusion-de-raster",
    "href": "12_modif_zone_terra.html#fusion-de-raster",
    "title": "12  Modifications de la zone d’étude",
    "section": "12.5 Fusion de raster",
    "text": "12.5 Fusion de raster\nIl est possible de fusionner plusieurs objets SpatRaster en un seul avec merge() ou mosaic().\n\n\n\nSite web ESRI\n\n\nAprès un découpage du raster d’élévation par la limite communale de Cahors (voir Section 12.2), nous réalisons la même chose pour la commune limitrophe de Bellefont-La Rauze.\n\n# Extraction des limites communales de Bellefont-La Rauze\nbellefont &lt;- subset(commune, commune$INSEE_COM == \"46156\") \n\n# Découpage du raster d'élévation en fonction des limites de Bellefont-La Rauze\ncrop_bellefont &lt;- crop(elev, bellefont)\n\nLes rasters d’élévation crop_cahors et crop_bellefont se chevauchent spatialement :\nplot(crop_cahors, main = \"Crop Cahors\")\nplot(cahors, add = TRUE)\nplot(bellefont, add = TRUE)\nplot(crop_bellefont, main = \"Crop Bellefont-La Rauze\")\nplot(bellefont, add = TRUE)\nplot(cahors, add = TRUE)\n\n\n\n\n\n\n\n\n\n\nLa différence entre les fonctions merge() ou mosaic() concerne les valeurs des cellules qui se superposent. La fonction mosaic() calcule la valeur moyenne tandis que merge() conserve la valeur du premier objet SpatRaster appelé dans la fonction.\n\n# Dans cet exemple, merge() et mosaic() donnent le même résultat\nmerge_raster &lt;- merge(crop_cahors, crop_bellefont)\nmosaic_raster &lt;- mosaic(crop_cahors, crop_bellefont)\n\nplot(merge_raster)\nplot(bellefont, add = TRUE)\nplot(cahors, add = TRUE)",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modifications de la zone d'étude</span>"
    ]
  },
  {
    "objectID": "12_modif_zone_terra.html#segregate",
    "href": "12_modif_zone_terra.html#segregate",
    "title": "12  Modifications de la zone d’étude",
    "section": "12.6 Segregate",
    "text": "12.6 Segregate\nLa fonction segregate()permet de décomposer un raster par valeur (ou modalité) en différentes couches matricielles.\n\nclc_by_class &lt;- segregate(clc, keep = TRUE, other = NA)\n\nplot(clc_by_class)\n\n\n\n\n\n\n\n\n\n\n\n\nRacine, E. B. (2016). The Visual Raster Cheat Sheet. https://rpubs.com/etiennebr/visualraster.",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modifications de la zone d'étude</span>"
    ]
  },
  {
    "objectID": "13_algebre_spatial_terra.html",
    "href": "13_algebre_spatial_terra.html",
    "title": "13  Algèbre spatiale",
    "section": "",
    "text": "13.1 Opérations locales\nL’algèbre spatiale se classifie en quatre groupes d’opération (Tomlin, 1990) :\nLes opérations locales concernent les calculs réalisés indépendamment sur une cellule, à partir d’une ou plusieurs couches (matrices).",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Algèbre spatiale</span>"
    ]
  },
  {
    "objectID": "13_algebre_spatial_terra.html#opérations-locales",
    "href": "13_algebre_spatial_terra.html#opérations-locales",
    "title": "13  Algèbre spatiale",
    "section": "",
    "text": "13.1.1 Remplacement de valeur\n\n# Remplace les valeurs -9999 par NA\nelev[elev[[1]]== -9999] &lt;- NA\n\n# Remplace les valeurs &lt; 1500 par NA\nelev[elev &lt; 1500]  &lt;- NA\n\n# Remplace les valeurs NA par 0\nelev[is.na(elev )] &lt;- 0\n\n\n\n13.1.2 Opération sur chaque cellule\n\n# Ajout de 1000 à la valeur de chaque cellule\nelev_1000 &lt;-  elev + 1000\n\n# Suppression de l'altitude médiane à la valeur de chaque cellule\nelev_med &lt;-  elev - global(x = elev, fun = median, na.rm = TRUE)[[1]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n13.1.3 Reclassification\nLa reclassification des valeurs d’un raster peut aussi bien être utilisée pour discrétiser des données quantitatives que pour catégoriser des modalités qualitatives.\nCela permet par exemple de répartir les 44 postes de la nomenclature CLC selon les 5 grands types d’occupation du territoire : territoires artificialisés, agricoles, forêts et milieux semi-naturels, zones humides et surfaces en eau. Pour cela, il est d’abord nécessaire de construire une table de correspondance avec la fonction matrix().\n\nreclassif &lt;- matrix(c(100, 199, 1,\n                      200, 299, 2,\n                      300, 399, 3,\n                      400, 499, 4,\n                      500, 599, 5),\n                    ncol = 3, \n                    byrow = TRUE)\nreclassif\n\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]  100  199    1\n#&gt; [2,]  200  299    2\n#&gt; [3,]  300  399    3\n#&gt; [4,]  400  499    4\n#&gt; [5,]  500  599    5\n\n\nLes valeurs comprises entre 100 et 199 seront remplacées par la valeur 1. Les valeurs comprises entre 200 et 299 seront remplacées par la valeur 2. Les valeurs comprises entre 300 et 399 seront remplacées par la valeur 3. …\nLa fonction classify() permet de réaliser la reclassification.\n\nclc_5 &lt;- classify(clc, rcl = reclassif)\n\nplot(clc_5, type = \"classes\")\n\n\n\n\n\n\n\n\nAffichage avec les intitulés et couleurs officiels des différentes catégories.\n\nplot(clc_5,\n     type = \"classes\",\n     levels = c(\"Territoires artificialisés\",\n                \"Territoires agricoles\",\n                \"Forêts et milieux semi-naturels\",\n                \"Surfaces en eau\"),\n     col = c(\"#E6004D\", \"#FFFFA8\", \"#80FF00\", \"#00CCF2\"), \n     plg = list(cex = 0.7))\n\n\n\n\n\n\n\n\n\n\n13.1.4 Opération sur plusieurs couches (ex: NDVI)\nIl est possible de calculer une valeur de cellule à partir de différentes valeurs stockées dans plusieurs couches d’un objet SpatRaster.\nL’exemple le plus courant est sans doute le calcul de l’indice de végétation normalisé (NDVI). Pour chaque cellule, on calcule une valeur à partir de deux couches de données matricielles d’une image satellite multispectrale.\n\n# Import d'une image satellite multispectrale\nSentinel2a &lt;- rast(\"data/Sentinel2A.tif\")\n\nSentinel2a\n\n#&gt; class       : SpatRaster \n#&gt; size        : 1242, 1061, 2  (nrow, ncol, nlyr)\n#&gt; resolution  : 9.997187, 9.997187  (x, y)\n#&gt; extent      : 570465.7, 581072.7, 6368052, 6380468  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : RGF93 v1 / Lambert-93 (EPSG:2154) \n#&gt; source      : Sentinel2A.tif \n#&gt; names       : T31TCK_20211012T105011_B04_10m, T31TCK_20211012T105011_B08_10m \n#&gt; min values  :                              1,                              4 \n#&gt; max values  :                          16112,                          11273\n\n\nCette image satellite multispectrale (résolution de 10m) datée du 12/10/2021, a été produite par le satellite Sentinel-2 et a été récupérée sur la plateforme Copernicus Open Access Hub. Une extraction des bandes spectrales Rouge et proche infrarouge, centrée sur le département du Lot a ensuite été réalisée.\n\nplot(Sentinel2a)\n\n\n\n\n\n\n\n\nPour alléger le code, on assigne les couches matricielles dans deux objets SpatRaster différents.\n\n# Bande spectrale rouge\nB04_Red &lt;- Sentinel2a[[1]]\n\n# Bande spectrale proche infrarouge\nB08_NIR &lt;-Sentinel2a[[2]]\n\nÀ partir de ces deux rasters, nous pouvons calculer l’indice de végétation normalisé :\n\\[{NDVI}=\\frac{\\mathrm{NIR} - \\mathrm{Red}} {\\mathrm{NIR} + \\mathrm{Red}}\\]\n\nraster_NDVI &lt;- (B08_NIR - B04_Red ) / (B08_NIR + B04_Red )\nplot(raster_NDVI)\n\n\n\n\n\n\n\n\nPlus les valeurs sont importantes (proche de 1), plus la végétation est dense.",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Algèbre spatiale</span>"
    ]
  },
  {
    "objectID": "13_algebre_spatial_terra.html#opérations-focales",
    "href": "13_algebre_spatial_terra.html#opérations-focales",
    "title": "13  Algèbre spatiale",
    "section": "13.2 Opérations focales",
    "text": "13.2 Opérations focales\nL’analyse focale considère une cellule plus ses voisins directs de manière contiguë et symétrique (opérations de voisinage). Le plus souvent, la valeur de la cellule de sortie est le résultat d’un bloc de cellules d’entrée 3 x 3 (nombre impair).\nLa première étape consiste à construire une matrice qui détermine le bloc de cellules qui sera pris en compte autour de chaque cellule.\n\n# Matrice 9 x 9, où chaque cellule présente la même pondération (1)\nmon_focal &lt;- matrix(1, nrow = 9, ncol = 9)\nmon_focal\n\n#&gt;       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n#&gt;  [1,]    1    1    1    1    1    1    1    1    1\n#&gt;  [2,]    1    1    1    1    1    1    1    1    1\n#&gt;  [3,]    1    1    1    1    1    1    1    1    1\n#&gt;  [4,]    1    1    1    1    1    1    1    1    1\n#&gt;  [5,]    1    1    1    1    1    1    1    1    1\n#&gt;  [6,]    1    1    1    1    1    1    1    1    1\n#&gt;  [7,]    1    1    1    1    1    1    1    1    1\n#&gt;  [8,]    1    1    1    1    1    1    1    1    1\n#&gt;  [9,]    1    1    1    1    1    1    1    1    1\n\n\nLa fonction focal() permet ensuite de réaliser l’analyse souhaitée. Par exemple : le calcul de la moyenne des valeurs dans une fenêtre spatiale determinée, pour chaque cellule du raster.\n\nelev_focal_mean &lt;- focal(elev, w = mon_focal, fun = mean)\n\nplot(elev, main = \"raster de départ\")\nplot(elev_focal_mean, main=\"résultat : focal 9 x 9, pondération uniforme\")\n\n\n\n\n\n\n\n\n\n\n\n13.2.1 Opération focales pour rasters d’élévation\nLa fonction terrain() permet de réaliser des analyses focales spécifiques au rasters d’élévation. Six opérations sont disponibles :\n\nslope = calcul de la pente ou degré d’inclinaison de la surface;\naspect = calcul de l’orientation de la pente;\nroughness = calcul de la variabilité ou l’irrégularité de l’élévation;\nTPI = calcul de l’indice des positions topographiques;\nTRI = calcul de l’indice de la variabilité de l’élévation;\nflowdir = calcul du sens d’écoulement de l’eau.\n\nExemples avec le calcul des pentes (slope), c’est à dire leur inclinaison en degrés.\n\nslope &lt;- terrain(elev, \"slope\",\n                 neighbors = 8, # 8 (ou 4) cellules autour pris en compte\n                 unit = \"degrees\") # Unité en sortie\n\nplot(slope)",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Algèbre spatiale</span>"
    ]
  },
  {
    "objectID": "13_algebre_spatial_terra.html#opérations-globales",
    "href": "13_algebre_spatial_terra.html#opérations-globales",
    "title": "13  Algèbre spatiale",
    "section": "13.3 Opérations globales",
    "text": "13.3 Opérations globales\nLes opérations globales permettent de résumer les valeurs matricielles d’une ou plusieurs matrices.\n\n# Valeur moyenne\nglobal(elev, fun = \"mean\", na.rm = TRUE)\n\n#&gt;              mean\n#&gt; altitude 251.3601\n\n# Écart-type\nglobal(elev, fun = \"sd\", na.rm = TRUE)\n\n#&gt;                sd\n#&gt; altitude 54.58627\n\n# Fréquence\nfreq(clc_5)\n\n#&gt;   layer value count\n#&gt; 1     1     1  3775\n#&gt; 2     1     2 38118\n#&gt; 3     1     3 56331\n#&gt; 4     1     5   928\n\n\nReprésentations statistiques qui résument les informations matricielles.\n\n# Histogramme\nhist(elev)\n\n\n\n\n\n\n\n# Densité\ndensity(elev)\n\n\n\n\n\n\n\n# boxplot\nboxplot(elev)\n\n#&gt; Warning: [boxplot] taking a sample of 1e+05 cells",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Algèbre spatiale</span>"
    ]
  },
  {
    "objectID": "13_algebre_spatial_terra.html#opérations-zonales",
    "href": "13_algebre_spatial_terra.html#opérations-zonales",
    "title": "13  Algèbre spatiale",
    "section": "13.4 Opérations zonales",
    "text": "13.4 Opérations zonales\nLes opérations zonales permettent de résumer les valeurs matricielles de certaines zones (groupe de cellules contiguë dans l’espace ou en valeur).\n\n13.4.1 Opération zonale à partir d’une couche vectorielle\nLa fonction extract() permet d’extraire et de manipuler les valeurs des cellules qui intersectent des données vectorielles.\nExemple à partir des limites communales :\n\ncommune &lt;- vect(\"data/lot.gpkg\", layer = \"communes\")\n\n# Moyenne d'élévation pour chaque polygone (commune) \nelev_by_com &lt;-  extract(elev, commune, fun = mean, na.rm = FALSE)\nhead(elev_by_com, n = 3)\n\n#&gt;   ID altitude\n#&gt; 1  1      NaN\n#&gt; 2  2      NaN\n#&gt; 3  3      NaN\n\n# Suppression des valeurs NaN\nelev_by_com &lt;- elev_by_com[!is.nan(elev_by_com$altitude),]\n\n# Remplacement des identifiants uniques par le nom des communes\nelev_by_com$ID &lt;- commune[elev_by_com$ID]$NOM_COM\nhead(elev_by_com, n = 6)\n\n#&gt;                    ID altitude\n#&gt; 7            Arcambal 213.0009\n#&gt; 10             Aujols 216.7961\n#&gt; 23 Belmont-Sainte-Foi 302.4436\n#&gt; 29         Boissières 252.0305\n#&gt; 39             Cahors 205.1988\n#&gt; 41            Caillac 145.9868\n\n\n\n\n13.4.2 Opération zonale à partir d’un raster\nLes opérations zonales peuvent être réalisées par zone délimitée par les valeurs catégorielles d’un second raster avec la fonction zonal(). Pour cela, les deux rasters doivent avoir exactement le même étendue et la même résolution.\n\n# Élévation moyenne pour chaque zone de clc\nzonal(elev, clc_5, \"mean\", na.rm = TRUE)\n\n#&gt;   clc altitude\n#&gt; 1   1 209.7177\n#&gt; 2   2 259.3624\n#&gt; 3   3 249.4070\n#&gt; 4   5 115.8435\n\n\n\n\n\n\nLi, X. (2009). Map algebra and beyond : 1. Map algebra for scalar fields. https://www.slideserve.com/emmak/topics-powerpoint-ppt-presentation\n\n\nTomlin, C. D. (1990). Geographic information systems and cartographic modeling. Prentice Hall.",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Algèbre spatiale</span>"
    ]
  },
  {
    "objectID": "14_transformation_terra.html",
    "href": "14_transformation_terra.html",
    "title": "14  Conversions",
    "section": "",
    "text": "14.1 Rasterisation\nTransformer des polygones en format raster avec la fonction rasterize().\ncommune &lt;- vect(\"data/lot.gpkg\", layer = \"communes\")\nelev &lt;- rast(\"data/elev.tif\") \n\nraster_commune &lt;- rasterize(x = commune, y = elev , field = \"NOM_COM\")\nplot(raster_commune)\nTransformer des points en format raster :\n# Rasterisation des centroïdes des communes\nraster_com_centroide &lt;- rasterize(x = centroids(commune), \n                                  y = elev, fun = sum)\nplot(raster_com_centroide, col = \"red\")\nTransformer des lignes format raster :\n# Rasterisation des limites communales\nraster_com_line &lt;- rasterize(x = as.lines(commune), y = elev, fun=sum)\nplot(raster_com_line)",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conversions</span>"
    ]
  },
  {
    "objectID": "14_transformation_terra.html#vectorisation",
    "href": "14_transformation_terra.html#vectorisation",
    "title": "14  Conversions",
    "section": "14.2 Vectorisation",
    "text": "14.2 Vectorisation\nTransformer un raster en polygones ou en points avec les fonctions as.polygons() et as.points(). Les objets créés sont dans le format SpatVector de terra.\nIl est ensuite possible de les transformer en objets sf avec la fonction st_as_sf().\n\nlibrary(terra)\nlibrary(sf)\nclc &lt;- rast(x = \"data/clc.tif\")\n\n# Reclassifions le raster CLC\nreclassif &lt;- matrix(c(100, 199, 1,\n                      200, 299, 2,\n                      300, 399, 3,\n                      400, 499, 4,\n                      500, 599, 5),\n                    ncol = 3, \n                    byrow = TRUE)\nclc &lt;- classify(clc, rcl = reclassif)\n\n# Changeons d'abord la résolution du raster CLC\nclc_lower_model &lt;- clc\nres(clc_lower_model) &lt;- 1000\n\nclc_lower &lt;- resample(x = clc, y = clc_lower_model, method = \"near\") \n\n# Transformation en polygones\nclc_poly &lt;- as.polygons(clc_lower)\nclc_poly &lt;- st_as_sf(clc_poly)\n\n# Affichage \nclc_poly$clc &lt;- as.factor(clc_poly$clc)\nplot(clc_poly[\"clc\"])\n\n\n\n\n\n\n\n\nTransformer un raster en points vectoriels avec la fonction as.points():\n\nclc_point &lt;- as.points(clc_lower)\nclc_point &lt;- st_as_sf(clc_point)\nclc_point$clc &lt;- as.factor(clc_point$clc)\nplot(clc_point[\"clc\"], pch = 20, cex = 2)",
    "crumbs": [
      "**Les données raster : le package terra**",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Conversions</span>"
    ]
  },
  {
    "objectID": "01_mapsf.html",
    "href": "01_mapsf.html",
    "title": "15  Le package mapsf",
    "section": "",
    "text": "15.1 Présentation\nL’écosystème spatial du logiciel libre R est riche, dynamique et mature et plusieurs packages permettent d’importer, de traiter et de représenter les données spatiales. Le package mapsf (Giraud, 2025) s’appuie sur cet écosystème pour intégrer la création de cartes thématiques de qualité dans les chaînes de traitements avec R.\nDans ce document, nous utiliserons principalement le package mapsf dont les fonctionnalités sont assez complètes et la prise en main plutôt simple. De plus, le package est relativement léger.\nmapsf permet de créer la plupart des types de carte utilisés habituellement en cartographie statistique (cartes choroplèthes, typologies, symboles proportionnels ou gradués…).\nPour chaque type de carte, plusieurs paramètres permettent de personnaliser la représentation cartographique. Ces paramètres sont les mêmes que ceux que l’on retrouve dans les logiciels de SIG ou de cartographie usuels (par exemple, le choix des discrétisations et des palettes de couleurs, la modification de de la taille des symboles ou la personnalisation des légendes).\nAssociées aux fonctions de représentation des données d’autres fonctions sont dédiées à l’habillage cartographique (thèmes ou chartes graphiques, légendes, échelles, flèches d’orientation, titre, crédits, annotations…), à la création de cartons ou à l’export des cartes.\nmapsf est le successeur de cartography (Giraud et Lambert, 2017), il offre les mêmes fonctionnalités principales tout en étant plus léger et plus ergonomique.",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Le package mapsf</span>"
    ]
  },
  {
    "objectID": "01_mapsf.html#présentation",
    "href": "01_mapsf.html#présentation",
    "title": "15  Le package mapsf",
    "section": "",
    "text": "Une chaîne de traitements typique\n\n\n\n\n\n\n\n\nD’autres packages peuvent être utilisés pour réaliser des cartes thématiques.\nLe package ggplot2 (Wickham, 2016), en association avec le package ggspatial (Dunnington, 2025), permet par exemple d’afficher des objets spatiaux et de réaliser des cartes thématiques simples.\nLe package tmap (Tennekes, 2018) est dédié à la création de cartes thématiques, il utilise une syntaxe proche de celle de ggplot2 (enchaînement d’instructions combinées avec le signe +).\nLa documentation et les tutoriels pour utiliser ces deux packages sont facilement accessibles sur le web.\n\n\n\n\n\n\n\nUn nombre minimal de dépendances bien connues",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Le package mapsf</span>"
    ]
  },
  {
    "objectID": "01_mapsf.html#documentation",
    "href": "01_mapsf.html#documentation",
    "title": "15  Le package mapsf",
    "section": "15.2 Documentation",
    "text": "15.2 Documentation\n\n\n\nSite web : \n\n\ncheat sheet : \n\n\n\nVignettes :\n\nGet started\nHow to create faceted maps\nHow to create inset maps\nHow to export maps\nHow to use a custom font family\nHow to use themes",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Le package mapsf</span>"
    ]
  },
  {
    "objectID": "01_mapsf.html#exercice",
    "href": "01_mapsf.html#exercice",
    "title": "15  Le package mapsf",
    "section": "Exercice",
    "text": "Exercice\n\nLes données utilisées dans ce document sont stockées dans un projet RStudio. Vous devez le télécharger puis le décompresser sur votre machine. Il vous sera ensuite possible de tester l’ensemble des manipulations proposées dans ce document au sein du projet geodata.\nTélécharger le projet\nNous utiliserons principalement le package mapsf dans la suite de ce document.\nInstallez le en utilisant la fonction install.packages().\nQuelle est la version du package?\nQuelles sont les nouveautés par rapport à la version précédente?\n\n\n\n\n\nDunnington, D. (2025). ggspatial: Spatial Data Framework for ggplot2. https://doi.org/10.32614/CRAN.package.ggspatial\n\n\nGiraud, T. (2025). mapsf: Thematic Cartography. https://doi.org/10.32614/CRAN.package.mapsf\n\n\nGiraud, T. et Lambert, N. (2017). Reproducible Cartography. M. Peterson (dir.), Cham, Switzerland (p. 173‑183). https://doi.org/10.1007/978-3-319-57336-6_13\n\n\nTennekes, M. (2018). tmap: Thematic Maps in R. Journal of Statistical Software, 84(6), 1‑39. https://doi.org/10.18637/jss.v084.i06\n\n\nWickham, H. (2016). ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. https://ggplot2.tidyverse.org",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Le package mapsf</span>"
    ]
  },
  {
    "objectID": "02_semiologie.html",
    "href": "02_semiologie.html",
    "title": "16  La sémiologie graphique",
    "section": "",
    "text": "16.1 Principes généraux\nPour une première approche de la cartographie thématique on peut se référer à la figure suivante qui résume de manière simplifiée la relation entre un type de variable et sa représentation graphique correcte.",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>La sémiologie graphique</span>"
    ]
  },
  {
    "objectID": "02_semiologie.html#principes-généraux",
    "href": "02_semiologie.html#principes-généraux",
    "title": "16  La sémiologie graphique",
    "section": "",
    "text": "La sémiologie graphique est, de façon générale, l’ensemble des règles qui régissent la construction d’un système de signes ou langage permettant la traduction graphique d’une information. Depuis la parution de la Sémiologie graphique de Jacques Bertin (1967), elle désigne surtout un ensemble standardisé des règles et de pratiques inhérentes à la représentation cartographique au-delà des travaux réalisés par Bertin.\nWikipedia : Sémiologie graphique\n\n\n\n\n\n\n\n\n\nPourquoi on ne représente pas de stocks en aplat !",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>La sémiologie graphique</span>"
    ]
  },
  {
    "objectID": "02_semiologie.html#ressources",
    "href": "02_semiologie.html#ressources",
    "title": "16  La sémiologie graphique",
    "section": "16.2 Ressources",
    "text": "16.2 Ressources\nVoici quelques ouvrages et ressources pour l’apprentissage de la cartographie thématique :\n\n\n\n\n\n\nBéguin et Pumain (2023)\n\n\n\n\n\n\n\nLambert et Zanin (2025)\n\n\n\n\n\n\n\nRIATE (2025)",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>La sémiologie graphique</span>"
    ]
  },
  {
    "objectID": "02_semiologie.html#exercice",
    "href": "02_semiologie.html#exercice",
    "title": "16  La sémiologie graphique",
    "section": "Exercice",
    "text": "Exercice\nComment représenter les variables suivantes :\n\nUne population communale\nUn age médian par département\nUn taux de croissance\nLe statut administratif d’une commune (préfecture, sous-préfecture, commune simple…)\nL’espérance de vie par pays\n\n\n\n\n\nBéguin, M. et Pumain, D. (2023). La représentation des données géographiques: Statistique et cartographie. Armand Colin.\n\n\nBertin, J. (1967). Sémiologie Graphique. Les Diagrammes - Les Réseaux - Les Cartes. Paris: Mouton & Gauthier-Villars.\n\n\nLambert, N. et Zanin, C. (2025). Manuel de cartographie: principes, méthodes, applications. Armand Colin.\n\n\nRIATE. (2025). Cartographie thématique avec Magrit. https://magrit-formation.github.io/",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>La sémiologie graphique</span>"
    ]
  },
  {
    "objectID": "03_types_de_cartes.html",
    "href": "03_types_de_cartes.html",
    "title": "17  Les types de cartes",
    "section": "",
    "text": "17.1 Les données d’exemple\nLa fonction mf_map() est la fonction centrale du package mapsf. Elle permet de réaliser la plupart des représentations usuelles en cartographie. Ces arguments principaux sont :\nLes lignes suivantes importent les couches d’information spatiales situées dans le fichier geopackage lot.gpkg.\nlibrary(sf)\n# import des communes du Lot\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\n# import des départements français\ndep &lt;- st_read(\"data/lot.gpkg\", layer = \"departements\", quiet = TRUE)\n# import des restaurants\nresto &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\n# import des routes autour de la commune de Gramat\nroute &lt;- st_read(\"data/lot.gpkg\", layer = \"routes\", quiet = TRUE)",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Les types de cartes</span>"
    ]
  },
  {
    "objectID": "03_types_de_cartes.html#afficher-un-fond-de-carte",
    "href": "03_types_de_cartes.html#afficher-un-fond-de-carte",
    "title": "17  Les types de cartes",
    "section": "17.2 Afficher un fond de carte",
    "text": "17.2 Afficher un fond de carte\nUtilisée sans précision de type, la fonction mf_map() affiche simplement les couches spatiales.\n\nlibrary(mapsf)\n# Communes (polygones)\nmf_map(x = com, border = \"white\")\n# Départements (polygones, fond transparent)\nmf_map(x = dep, lwd = 2, col = NA, add = TRUE)\n# Routes (polylignes)\nmf_map(x = route, lwd = .7, col = \"ivory4\", add = TRUE)\n# Restaurants (points)\nmf_map(x = resto, pch = 20, cex = .7, col = \"darkred\", add = TRUE)\n# Ajour d'un titre\nmf_title(txt = \"Le Lot (46)\")",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Les types de cartes</span>"
    ]
  },
  {
    "objectID": "03_types_de_cartes.html#carte-de-symboles-proportionnels",
    "href": "03_types_de_cartes.html#carte-de-symboles-proportionnels",
    "title": "17  Les types de cartes",
    "section": "17.3 Carte de symboles proportionnels",
    "text": "17.3 Carte de symboles proportionnels\nLes cartes de symboles proportionnels sont utilisées pour représenter les variables de stocks (variables quantitatives absolues, la somme et la moyenne ont un sens). La fonction mf_map(..., type = \"prop\") propose cette représentation.\n\n# Communes\nmf_map(x = com)\n# Symboles proportionnels\nmf_map(\n  x = com, \n  var = \"POPULATION\",\n  type = \"prop\",\n  leg_title = \"Population totale\\n(2015)\"\n)\n# Titre\nmf_title(\"Distribution de la population dans le Lot\")",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Les types de cartes</span>"
    ]
  },
  {
    "objectID": "03_types_de_cartes.html#carte-choroplèthe",
    "href": "03_types_de_cartes.html#carte-choroplèthe",
    "title": "17  Les types de cartes",
    "section": "17.4 Carte choroplèthe",
    "text": "17.4 Carte choroplèthe\nLes cartes choroplèthes sont utilisées pour représenter les variables de ratios (variables quantitatives relatives, la moyenne a un sens, la somme n’a pas de sens).\nLa fonction mf_map(..., type = \"choro\") permet de créer des cartes choroplètes. Les arguments nbreaks et breaks servent à paramétrer les discrétisations.\n\n# Densité de population (hab./km2) en utilisant la fonction sf::st_area()\ncom$DENS &lt;- 1e6 * com$POPULATION / as.numeric(st_area(com))\nmf_map(\n  x = com,\n  var = \"DENS\",\n  type = \"choro\",\n  breaks = \"quantile\",\n  nbreaks = 6,\n  pal = \"Dark Mint\",\n  lwd = 1,\n  leg_title = \"Densité de population\\n(habitants par km2)\", \n  leg_val_rnd = 0\n)\nmf_title(\"Distribution de la population dans le Lot (2018)\")\n\n\n\n\n\n\n\n\n\n17.4.1 Les palettes de couleurs\nL’argument pal de mf_map() est dédié au choix d’une palette de couleur. pal peut être le nom d’une palette de couleur fournie par R ou alors un vecteur de couleurs définies par leurs codes hexadécimaux.\nmf_map(x = com, var = \"DENS\", type = \"choro\",\n       breaks = \"quantile\", nbreaks = 4, \n       pal = \"Peach\")\nmf_title(\"Palette définie par son nom\")\nma_palette &lt;- c(\"#F3CAD2\", \"#E08BB1\", \"#AF4F91\", \"#6D1C68\")\nmf_map(x = com, var = \"DENS\", type = \"choro\",\n       breaks = \"quantile\", nbreaks = 4, \n       pal = ma_palette)\nmf_title(\"Palette définie par un vecteur de couleurs\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes palettes de R\n\n\nLes fonctions hcl.colors() et mf_get_pal() permettent de construire des palettes de couleurs. mf_get_pal() est surtout utile pour créer des palettes divergentes asymétriques équilibrées.\n\npal_equilibre &lt;- mf_get_pal(n = c(6,3), palette = c(\"Burg\", \"Teal\"))\npal_non_equi &lt;- c(hcl.colors(6, \"Burg\"), hcl.colors(3,\"Teal\", rev = TRUE))\nlibrary(maplegend)\nopar &lt;- par(mar = c(0,0,0,0))\nplot.new()\nplot.window(xlim = c(0, 1), ylim = c(0, 1), asp = 1)\nleg(type = \"choro\", val = rep(\"\", 10), \n    pal = pal_equilibre, pos = \"topleft\", \n    title = \"Palette équilibrée\")\nleg(type = \"choro\", val = rep(\"\", 10), \n    pal = pal_non_equi, pos = \"top\", \n    title = \"Palette non équilibrée\")\npar(opar)\n\n\n\n\n\n\n\n\n\n\n17.4.2 Discrétisations\nAvant de réaliser une carte choroplèthe on doit d’abord étudier la distribution statistique de la variable que l’on souhaite cartographier. La fonction mf_distr() permet de visualiser les distributions.\n\nmf_distr(com$DENS)\n\n\n\n\n\n\n\n\nCette distribution est très dissymétrique à gauche.\nLa fonction mf_get_breaks() met à disposition les méthodes de discrétisations de variables classique : quantiles, moyenne/écart-type, amplitudes égales, moyennes emboîtées, Fisher-Jenks, géométrique…\nIci, l’utilisation de la méthode “geom” est assez appropriée.\n\nbks &lt;- mf_get_breaks(x = com$DENS, nbreaks = 5, breaks = \"geom\") \nbks\n\n#&gt; [1]   4.113775  11.033758  29.594181  79.376000 212.898252 571.024813\n\nmf_map(\n  x = com, var = \"DENS\", type = \"choro\",\n  breaks = bks, pal = \"Blues\",\n  lwd = 1,\n  leg_title = \"Population density\\n(inh. per km2)\", \n  leg_val_rnd = 0\n)\nmf_title(\"Distribution de la population dans le Lot (2018)\")",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Les types de cartes</span>"
    ]
  },
  {
    "objectID": "03_types_de_cartes.html#carte-de-typologie",
    "href": "03_types_de_cartes.html#carte-de-typologie",
    "title": "17  Les types de cartes",
    "section": "17.5 Carte de typologie",
    "text": "17.5 Carte de typologie\nLes cartes de typologies sont utilisées pour représenter les variables qualitatives.\nLa fonction mf_map(..., type = \"typo\") propose cette représentation.\n\nmf_map(\n  x = com,\n  var=\"STATUT\",\n  type = \"typo\",\n  pal = c(\"aquamarine4\", \"yellow3\",\"wheat\"),\n  lwd = .7,\n  leg_title = \"\"\n)\nmf_title(\"Statut administratif des communes\")\n\n\n\n\n\n\n\n\nL’argument val_order sert à ordonner les modalités dans la légende.\n\nmf_map(\n  x = com,\n  var=\"STATUT\",\n  type = \"typo\",\n  pal = c(\"aquamarine4\", \"yellow3\",\"wheat\"),\n  val_order = c(\"Préfecture\", \"Sous-préfecture\", \"Commune simple\"),\n  lwd = .7,\n  leg_title = \"\"\n)\nmf_title(\"Statut administratif des communes\")",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Les types de cartes</span>"
    ]
  },
  {
    "objectID": "03_types_de_cartes.html#carte-de-stocks-et-de-ratios",
    "href": "03_types_de_cartes.html#carte-de-stocks-et-de-ratios",
    "title": "17  Les types de cartes",
    "section": "17.6 Carte de stocks et de ratios",
    "text": "17.6 Carte de stocks et de ratios\nLa fonction mf_map(..., var = c(\"var1\", \"var2\"), type = \"prop_choro\") représente des symboles proportionnels dont les surfaces sont proportionnelles aux valeurs d’une variable et dont la couleur repose sur la discrétisation d’une seconde variable. La fonction utilise les arguments des fonctions mf_map(..., type = \"prop\") et mf_map(..., type = \"choro\").\n\nmf_map(x = com)\nmf_map(\n  x = com,\n  var = c(\"POPULATION\", \"DENS\"),\n  type = \"prop_choro\",\n  border = \"grey90\",\n  leg_title = c(\"Population\", \"Densité\\nde population\\n(en hab./km2)\"),\n  breaks = \"q6\",\n  pal = \"Magenta\",\n  leg_val_rnd = c(0,1))\nmf_title(\"Distribution de la population dans le Lot (2018)\")",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Les types de cartes</span>"
    ]
  },
  {
    "objectID": "03_types_de_cartes.html#carte-de-stocks-et-de-catégories",
    "href": "03_types_de_cartes.html#carte-de-stocks-et-de-catégories",
    "title": "17  Les types de cartes",
    "section": "17.7 Carte de stocks et de catégories",
    "text": "17.7 Carte de stocks et de catégories\nLa fonction mf_map(..., var = c(\"var1\", \"var2\"), type = \"prop_typo\") représente des symboles proportionnels dont les surfaces sont proportionnelles aux valeurs d’une variable et dont la couleur représente les modalités d’une variable qualitative. La fonction utilise les arguments des fonctions mf_map(..., type = \"prop\") et mf_map(..., type = \"typo\").\n\nmf_map(x = com)\nmf_map(\n  x = com,\n  var = c(\"POPULATION\", \"STATUT\"),\n  type = \"prop_typo\",\n  pal = c(\"coral4\", \"chocolate\",\"darksalmon\"),\n  val_order = c(\"Préfecture\", \"Sous-préfecture\", \"Commune simple\"),\n  leg_pos = \"topleft\",\n  leg_title = c(\"Population\\n(2015)\",\n                \"Statut administratif\"),\n)\nmf_title(\"Distribution de la population dans le Lot (2018)\")",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Les types de cartes</span>"
    ]
  },
  {
    "objectID": "03_types_de_cartes.html#exercice",
    "href": "03_types_de_cartes.html#exercice",
    "title": "17  Les types de cartes",
    "section": "Exercice",
    "text": "Exercice\n\nImporter la couche des communes du département du Lot à partir du fichier geopackage lot.gpkg.\nImporter le fichier com.csv.\nCe jeu de données porte sur les communes du Lot et contient plusieurs variables supplémentaires:\n\nle nombre d’actifs (ACT).\nle nombre d’actifs dans l’industrie (IND)\nla part des actifs dans la population totale (SACT)\nla part des actifs dans l’industrie dans le total des actifs (SACT_IND)\n\nJoindre le jeu de données et la couche des communes.\nCréer une carte de la population active.\nQuel mode de représentation utiliser? Quels choix cela implique-t-il?\nCréer une carte de la part de la population active dans la population totale.\nQuel mode de représentation utiliser? Quels choix cela implique-t-il?\n\n\n\n\n\n\n\nVous pouvez utiliser le fichier exo_cartographie_simple.R pour vous guider dans cette exercice.",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Les types de cartes</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html",
    "href": "04_mise_en_page.html",
    "title": "18  La mise en page",
    "section": "",
    "text": "18.1 Les données d’exemple\nPour être finalisée, une carte thématique doit contenir certains éléments additionnels tels que : le titre, l’auteur, la source, l’échelle, l’orientation…\nLes lignes suivantes importent les couches d’information spatiales situées dans le fichier geopackage lot.gpkg.\nlibrary(sf)\n# import des communes du Lot\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\n# import des départements français\ndep &lt;- st_read(\"data/lot.gpkg\", layer = \"departements\", quiet = TRUE)\n# import des restaurants\nresto &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\n# import des routes autour de la commune de Gramat\nroute &lt;- st_read(\"data/lot.gpkg\", layer = \"routes\", quiet = TRUE)",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#les-thèmes",
    "href": "04_mise_en_page.html#les-thèmes",
    "title": "18  La mise en page",
    "section": "18.2 Les thèmes",
    "text": "18.2 Les thèmes\nLa fonction mf_theme() définit un thème cartographique. L’utilisation d’un thème permet de définir plusieurs paramètres graphiques qui sont ensuite appliqués aux cartes créées avec mapsf. Ces paramètres sont :\n\nles marges de la carte\nles couleurs principale, d’arrière-plan et de premier plan\nla position et l’aspect du titre\nles palettes de couleurs utilisées par défaut\n\n\n18.2.1 Utiliser un thème prédéfini\nUne série de thèmes prédéfinis est disponible par défaut (voir ?mf_theme).\nlibrary(mapsf)\nmf_theme(\"base\")\nmf_map(com)\nmf_title(\"Theme : 'base'\")\nmf_theme(\"dracula\")\nmf_map(com)\nmf_title(\"Theme : 'dracula'\")\nmf_theme(\"sol_light\")\nmf_map(com)\nmf_title(\"Theme : 'sol_light'\")\nmf_theme(\"sol_dark\")\nmf_map(com)\nmf_title(\"Theme : 'sol_dark'\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n18.2.2 Modifier un thème existant\nIl est possible de modifier un thème existant. Dans cet exemple, nous utilisons le thème “base” et nous en modifions quelques paramètres.\ncom$DENS &lt;- 1e6 * com$POPULATION / as.numeric(st_area(com))\nmf_theme(\"base\")\nmf_map(com)\nmf_title(\"Theme : 'base'\")\nmf_theme(\"sol_light\")\nmf_map(com, \"DENS\", \"choro\", breaks = \"ckmeans\", nbreaks = 4)\nmf_title(\"Theme : 'sol_light'\")\nmf_theme(\n  x = \"base\",\n  mar = c(.5, .5, 3.25, .5),\n  highlight = \"#14184b\",\n  title_line = 2.75, \n  title_cex = 2,\n  title_pos = \"left\",\n  title_font = 3\n)\nmf_map(com)\nmf_title(\"Theme : 'base modifié'\")\nmf_theme(\n  \"sol_light\",\n  highlight = \"coral4\", \n  title_banner = TRUE, \n  pal_seq = \"Teal\"\n)\nmf_map(com, \"DENS\", \"choro\", breaks = \"ckmeans\", nbreaks = 4)\nmf_title(\"Theme : 'sol_light' modifié\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteVignette\n\n\n\nHow to Use Themes",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#les-titres",
    "href": "04_mise_en_page.html#les-titres",
    "title": "18  La mise en page",
    "section": "18.3 Les titres",
    "text": "18.3 Les titres\nLa fonction mf_title() permet d’ajouter un titre à une carte.\n\nmf_theme(\"base\")\nmf_map(com)\nmf_title(\"Titre de la carte\")\n\n\n\n\n\n\n\n\nIl est possible de personnaliser l’aspect du titre.\n\nmf_map(com)\nmf_title(\n  txt = \"Titre de la carte\",\n  pos = \"left\",\n  tab = TRUE,\n  bg = \"#940000\",\n  fg = \"#ffffff\",\n  font = 1\n)",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#flèche-dorientation-et-échelle",
    "href": "04_mise_en_page.html#flèche-dorientation-et-échelle",
    "title": "18  La mise en page",
    "section": "18.4 Flèche d’orientation et échelle",
    "text": "18.4 Flèche d’orientation et échelle\nLa fonction mf_arrow() permet de choisir la position et l’aspect de la flèche d’orientation.\nLa fonction mf_scale() permet de choisir la position et l’aspect de l’échelle.\n\nmf_map(com)\nmf_scale(size = 20, lwd = 2, cex = 1.2)\nmf_arrow()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteToutes les cartes doivent avoir une échelle et une flèche d’orientation !?\n\n\n\n\n\n\n\n\n\n\n\n\n\nCarnet Observable interactif de Nicolas Lambert",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#crédits",
    "href": "04_mise_en_page.html#crédits",
    "title": "18  La mise en page",
    "section": "18.5 Crédits",
    "text": "18.5 Crédits\nLa fonction mf_credits() permet d’afficher une ligne de crédits (sources, auteur…).\n\nmf_map(com)\nmf_credits(\"Auteurs : TG & HP\\nSources : IGN, 2018\")",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#habillage-complet",
    "href": "04_mise_en_page.html#habillage-complet",
    "title": "18  La mise en page",
    "section": "18.6 Habillage complet",
    "text": "18.6 Habillage complet\nLa fonction mf_layout() permet d’afficher tous ces éléments (titre, c.\n\nmf_map(com)\nmf_layout(\n  title = \"Le Lot\",\n  credits = \"Auteurs : TG & HP\\nSources : IGN, 2018\",\n  arrow = TRUE, \n  scale = TRUE\n)",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#cadre",
    "href": "04_mise_en_page.html#cadre",
    "title": "18  La mise en page",
    "section": "18.7 Cadre",
    "text": "18.7 Cadre\nLa fonction mf_frame() permet de reajouter un cadre autour de la carte.\n\nmf_map(com)\nmf_title(\"Le Lot\")\nmf_frame(lty = 2)",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#annotations",
    "href": "04_mise_en_page.html#annotations",
    "title": "18  La mise en page",
    "section": "18.8 Annotations",
    "text": "18.8 Annotations\n\n# Sélection d'une commune\ncahors &lt;- com[com$NOM_COM == \"Cahors\", ]\nmf_map(com)\nmf_annotation(\n  x = cahors, \n  txt = \"Cahors\", \n  halo = TRUE, \n  cex = 1.5\n)",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#étiquettes",
    "href": "04_mise_en_page.html#étiquettes",
    "title": "18  La mise en page",
    "section": "18.9 Étiquettes",
    "text": "18.9 Étiquettes\nLa fonction mf_label() est dédiée à l’affichage d’étiquettes.\n\n# Selection des communes qui intersectent la \n# commune de Cahors\ncom_sel &lt;- st_filter(com, com[com$NOM_COM == \"Cahors\", ])\nmf_map(com_sel)\nmf_label(\n  x = com_sel,\n  var = \"NOM_COM\",\n  col= \"black\",\n  halo = TRUE,\n  overlap = FALSE, \n  lines = FALSE\n)\nmf_scale()\n\n\n\n\n\n\n\n\nL’argument halo = TRUE permet d’afficher un léger halo autour des étiquettes et l’argument overlap = FALSE permet de créer des étiquettes ne se recouvrant pas.",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#les-légendes",
    "href": "04_mise_en_page.html#les-légendes",
    "title": "18  La mise en page",
    "section": "18.10 Les légendes",
    "text": "18.10 Les légendes\nLa fonction mf_legend() permet d’afficher des légendes.\n\nmf_map(com)\nmf_legend(\n  type = \"prop\", \n  val = c(1000,500,200,10), \n  inches = .4, \n  title = \"Population\", \n  pos = \"topleft\"\n)\nmf_legend(\n  type = \"choro\", \n  val = c(0,10,20,30,40),\n  pal = \"Greens\", \n  pos = \"bottomright\", \n  val_rnd = 0\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteLe package maplegend\n\n\n\nLa fonction mf_legend() s’appuie sur le package maplegend (Giraud, 2025).",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#centrer-la-carte-sur-une-région",
    "href": "04_mise_en_page.html#centrer-la-carte-sur-une-région",
    "title": "18  La mise en page",
    "section": "18.11 Centrer la carte sur une région",
    "text": "18.11 Centrer la carte sur une région\nLa fonction mf_map() permet d’initialiser une carte en la centrant sur une objet spatial en choisissant un fond et des bordures transparantes.\n\nmf_map(x = com_sel, col = NA, border = NA)\nmf_map(com, add = TRUE)\nmf_map(com_sel, col = NA, border = \"red\", lwd = 2, add = TRUE)",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#afficher-plusieurs-cartes-sur-la-même-figure",
    "href": "04_mise_en_page.html#afficher-plusieurs-cartes-sur-la-même-figure",
    "title": "18  La mise en page",
    "section": "18.12 Afficher plusieurs cartes sur la même figure",
    "text": "18.12 Afficher plusieurs cartes sur la même figure\nIl faut ici utiliser l’argument mfrow de la fonction par(). Le premier chiffre représente le nombre lignes et le deuxième le nombre de colonnes.\nPar exemple par(mfrow = c(1, 2)) (1 ligne et 2 colonnes) permet d’afficher deux cartes côte à côte.\n\n# define the figure layout (1 row, 2 columns)\nopar &lt;- par(mfrow = c(1, 2))\n# define theme\nmf_theme(\"base\", mar = c(0,0,1.75,0))\n# first map\nmf_map(com)\nmf_map(com, \"TER_F\", \"prop\", \n       inches = .2,\n       val_max = 4000, \n       leg_pos = \"topleft\", \n       leg_title = \"N.\")\nmf_title(\"Tertiaire: Femmes\")\n# second map\nmf_map(com)\nmf_map(com, \"TER_H\", \"prop\",\n       inches = .2,\n       val_max = 4000, \n       leg_pos = NA)\nmf_title(\"Hommes\")\npar(opar)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteComparer des cartes de cercles proportionnels\n\n\n\nNotons ici l’utilisation des arguments inches et val_max avec des valeurs identiques pour les deux carte. Cela rend possible les comparaisons entres les deux cartes.\n\n\n\n\n\n\n\n\nNoteVignette\n\n\n\nHow to Create Faceted Maps",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#export-des-cartes",
    "href": "04_mise_en_page.html#export-des-cartes",
    "title": "18  La mise en page",
    "section": "18.13 Export des cartes",
    "text": "18.13 Export des cartes\nLes fonctions mf_svg() et mf_png() exportent respectivement les cartes aux formats SVG et PNG.\nL’export SVG est celui à privilégier pour éditer les cartes avec un logiciel de dessin vectoriel (Inkscape par exemple). Le format SVG est un format vectoriel. Le formar PNG doit être utilisée pour les cartes qui ne nécessitent pas de modification ultérieure. Le format PNG est un format de fichier raster.\nLe rapport largeur/hauteur de la carte exportée correspond à celui d’un objet spatial. Si la largeur est spécifiée, la hauteur est déduite du rapport largeur/hauteur de x. À l’inverse, si la hauteur est spécifiée, la largeur est déduite du rapport largeur/hauteur de x. Cela permet de produire des cartes sans trop d’espace perdu.\nCes fonctions peuvent aussi être utilisées pour ajouter de l’espace sur un ou plusieurs côté de la carte.\n\n#création d'un thème personnel\nmf_theme(\"sol_dark\")\nmf_png(\n  x = com, \n  filename = \"img/com_default.png\",\n  width = 600\n)\nmf_map(com)\nmf_title(\"Le Lot\")\ndev.off()\n\n\nL’emprise de cette carte est exactement celle de la région affichée.\nLors de l’export suivant nous ajoutons de l’espace sur la partie droite de la carte (50% de la largeur de x).\n\nmf_png(\n  x = com, \n  filename = \"img/com_expand.png\",\n  width = 600, \n  expandBB = c(0, 0, 0, .5)\n)\nmf_map(com, expandBB = c(0, 0, 0, .5))\nmf_title(\"Le Lot\")\ndev.off()\n\n\n\n\n\n\n\n\nNoteVignette\n\n\n\nHow to Export Maps",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#ajouter-une-image-sur-une-carte",
    "href": "04_mise_en_page.html#ajouter-une-image-sur-une-carte",
    "title": "18  La mise en page",
    "section": "18.14 Ajouter une image sur une carte",
    "text": "18.14 Ajouter une image sur une carte\nCela peut être utile pour ajouter un logo, un pictogramme. La fonction readPNG() du package png permet l’ajout d’images sur une figure.\n\nmf_theme(\"base\", mar = c(0,0,0,0))\nlibrary(png)\n# import de l'image\nlogo &lt;- readPNG(\"img/Logo CG 46 - Bleu.png\")\n# dimension de l'image en unité de la carte\npp &lt;- dim(logo)[2:1] * 20\n# Définition d'un point d'encrage de l'image dans la figure, ici\n# le coin supérieur gauche de la bounding box du département\nxy &lt;- st_bbox(com)[c(1,4)]\nmf_map(com, col = \"#D1914D\", border = \"white\")\nrasterImage(\n  image   = logo,\n  xleft   = xy[1],\n  ybottom = xy[2] - pp[2],\n  xright  = xy[1] + pp[1],\n  ytop    = xy[2]\n)",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#placer-précisément-un-élément-sur-la-carte",
    "href": "04_mise_en_page.html#placer-précisément-un-élément-sur-la-carte",
    "title": "18  La mise en page",
    "section": "18.15 Placer précisément un élément sur la carte",
    "text": "18.15 Placer précisément un élément sur la carte\nDans plusieurs fonctions de mapsf il est possible de placer des éléments d’habillage de manière interactive avec la position “interactive”.\n\n\n\n\n\n\n\nPlus généralement la fonction locator() permet de cliquer sur une figure et d’obtenir les coordonnées d’un point dans le système de coordonnées de la figure (de la carte). locator()peut être utilisée sur la plupart des graphiques (pas ceux produits avec ggplot2).",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#ajouter-un-ombrage-à-une-couche",
    "href": "04_mise_en_page.html#ajouter-un-ombrage-à-une-couche",
    "title": "18  La mise en page",
    "section": "18.16 Ajouter un ombrage à une couche",
    "text": "18.16 Ajouter un ombrage à une couche\nLa fonction mf_shadow() permet de créer une ombre à une couche de polygones.\n\nmf_theme(\"base\")\nmf_shadow(com)\nmf_map(com, add=TRUE)",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#création-de-cartons",
    "href": "04_mise_en_page.html#création-de-cartons",
    "title": "18  La mise en page",
    "section": "18.17 Création de cartons",
    "text": "18.17 Création de cartons\nLa fonction mf_inset_on() permet de démarrer la création d’un carton. Il faut ensuite “refermer” le carton avec mf_inset_off().\n\n# sélection d'une commune\nbiars &lt;- com[com$NOM_COM == \"Biars-sur-Cère\", ]\n# choix d'un thème\nmf_theme(\"sol_dark\")\n# affichage de toutes les communes\nmf_map(com)\n# affichage de la sélection de communes\nmf_map(biars, col = \"tomato4\", border = \"tomato1\", \n       lwd = 2, add = TRUE)\n\n# Démarrer le carton \n# en haut à gauche sur\n# le ratio width/height de biars\n# avec une largeur d'1/4 de la largeur de la figure\nmf_inset_on(x = biars, pos = \"topleft\", cex = .25)\n# affichage de la commune cible\nmf_map(biars, col = \"tomato4\", border = \"tomato1\")\n# affichage des communes\nmf_map(com, col = NA, add = TRUE)\n# échelle\nmf_scale(size = 1, pos = \"bottomright\")\n# affichage d'un cadre\nbox()\n# Fermer le carton\nmf_inset_off()\n\n# Ajouter titre et échelle\nmf_title(\"Biars-sur-Cère\")\nmf_scale(10, pos = 'bottomright')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteCarton “carte du monde”\n\n\n\nOn peut facilement créer un carton avec la position d’un point sur une carte du monde en combinant les fonctions mf_worldmap() et mf_inset_on(x = \"worldmap\", ...) :\n\nmf_theme(\"rzine\", frame = FALSE)\nmf_map(com)\nmf_inset_on(x = \"worldmap\",cex = .3, pos = \"topleft\")\nmf_worldmap(com)\nmf_inset_off()\nmf_title(\"Le Lot dans le Monde!\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteVignette\n\n\n\nHow to Create Inset Maps",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "04_mise_en_page.html#exercice",
    "href": "04_mise_en_page.html#exercice",
    "title": "18  La mise en page",
    "section": "Exercice",
    "text": "Exercice\n\nImporter la couche des communes du département du Lot à partir du fichier geopackage lot.gpkg.\nImporter le fichier com.csv.\nCe jeu de données porte sur les communes du lot et contient plusieurs variables supplémentaires:\n\nle nombre d’actifs (ACT).\nle nombre d’actifs dans l’industrie (IND)\nLa part des actifs dans la population totale (SACT)\nLa part des actifs dans l’industrie dans le total des actifs (SACT_IND)\n\nJoindre le jeu de données et la couche des communes.\nCréez une carte représentant la population active travaillant dans l’industrie.\nAjoutez les éléments d’habillage indispensables.\nUtilisez un thème personnalisé.\nAjoutez un carton de localisation du Lot.\nExportez la carte au format PNG avec 800 pixels de large.\nComment rendre la carte plus intelligible ? Allez-y !\n\n\n\n\n\n\n\nVous pouvez utiliser le fichier exo_cartographie_mise_en_page.R pour vous guider dans cette exercice.\n\n\n\n\n\n\n\nGiraud, T. (2025). maplegend: Legends for Maps. https://doi.org/10.32614/CRAN.package.maplegend",
    "crumbs": [
      "**Cartographie thématique**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>La mise en page</span>"
    ]
  },
  {
    "objectID": "15_OSM.html",
    "href": "15_OSM.html",
    "title": "19  OpenStreetMap",
    "section": "",
    "text": "OpenStreetMap (OSM) est un projet de cartographie participative qui a pour but de constituer une base de données géographiques libre à l’échelle mondiale. OpenStreetMap vous permet de voir, modifier et utiliser des données géographiques dans le monde entier.\nConditions d’utilisation\n\nOpenStreetMap est en données ouvertes : vous êtes libre de l’utiliser pour n’importe quel but tant que vous créditez OpenStreetMap et ses contributeurs. Si vous modifiez ou vous appuyez sur les données d’une façon quelconque, vous pouvez distribuer le résultat seulement suivant la même licence. (…)\n\nContributeurs\n\n(…) Nos contributeurs incluent des cartographes enthousiastes, des professionnels du SIG, des ingénieurs qui font fonctionner les serveurs d’OSM, des humanitaires cartographiant les zones dévastées par une catastrophe et beaucoup d’autres. (…)\n\n\n\n\n\n\n\nNoteA propos d’OpenStreetMap",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>OpenStreetMap</span>"
    ]
  },
  {
    "objectID": "16_OSM_interactif.html",
    "href": "16_OSM_interactif.html",
    "title": "20  Cartes interactives",
    "section": "",
    "text": "20.1 leaflet\nLes deux principaux packages qui permettent d’afficher une carte interactive basée sur OSM sont leaflet (Cheng et al., 2025) et mapview (Appelhans et al., 2025).\nleaflet utilise la libraire javascript Leaflet (Agafonkin, s. d.) pour créer des cartes interactives.\nlibrary(sf)\n\n#&gt; Linking to GEOS 3.13.1, GDAL 3.10.3, PROJ 9.6.0; sf_use_s2() is TRUE\n\nlibrary(leaflet)\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\nrestaurant &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\n\n# Sélection de la commune de Cahors\ncahors &lt;- com[com$INSEE_COM == \"46042\", ]\n\n# Sélection des restaurants de Cahors\nrestaurant_cahors &lt;- st_filter(restaurant, cahors)\n\n# transformation du système de coordonnées en WGS84\ncahors &lt;- st_transform(cahors, 4326)\nrestaurant_cahors &lt;- st_transform(restaurant_cahors, 4326)\n\n# Création de la carte interactive\nm &lt;- leaflet(cahors) %&gt;%\n  addTiles() %&gt;%\n  addPolygons() %&gt;%\n  addMarkers(data = restaurant_cahors)\nm",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Cartes interactives</span>"
    ]
  },
  {
    "objectID": "16_OSM_interactif.html#leaflet",
    "href": "16_OSM_interactif.html#leaflet",
    "title": "20  Cartes interactives",
    "section": "",
    "text": "NoteSite web de leaflet\n\n\n\nAn R Interface to Leaflet Maps",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Cartes interactives</span>"
    ]
  },
  {
    "objectID": "16_OSM_interactif.html#mapview",
    "href": "16_OSM_interactif.html#mapview",
    "title": "20  Cartes interactives",
    "section": "20.2 mapview",
    "text": "20.2 mapview\n mapview s’appuie sur leaflet pour créer des cartes interactives, son utilisation basique est plus simple bien que sa documentation ne soit pas vraiment facile à aborder.\n\nlibrary(mapview)\nmapview(cahors) + mapview(restaurant_cahors)\n\n\n\n\n\n\n\n\n\n\n\nNoteSite web de mapview\n\n\n\nInteractive viewing of spatial data in R\n\n\n\n\n\n\nAgafonkin, V. (s. d.). Leaflet, a JavaScript library for interactive maps. https://leafletjs.com/\n\n\nAppelhans, T., Detsch, F., Reudenbach, C. et Woellauer, S. (2025). mapview: Interactive Viewing of Spatial Data in R. https://doi.org/10.32614/CRAN.package.mapview\n\n\nCheng, J., Schloerke, B., Karambelkar, B., Xie, Y. et Aden-Buie, G. (2025). leaflet: Create Interactive Web Maps with the JavaScript ’Leaflet’ Library. https://doi.org/10.32614/CRAN.package.leaflet",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Cartes interactives</span>"
    ]
  },
  {
    "objectID": "17_OSM_static.html",
    "href": "17_OSM_static.html",
    "title": "21  Import de fonds de carte",
    "section": "",
    "text": "21.0.1 Fonds de cartes raster\n\nLe package maptiles (Giraud, 2025b) permet de télécharger et d’afficher des fonds de cartes raster. La fonction get_tiles() permet de télécharger des fonds de cartes OSM au format SpatRaster du package terra.\nDans cette exemple nous utilisons le package mapsf pour afficher la carte.\nLes rendus sont meilleurs si les données en entrée utilisent le même système de coordonnées que les tuiles (EPSG:3857).\n\nlibrary(sf)\nlibrary(maptiles)\nlibrary(mapsf)\n\ncom_raw &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\ncom &lt;- st_transform(com_raw, 3857)\n\n# Récupération d'un fond de carte OSM\nosm_tiles &lt;- get_tiles(x = com, zoom = 9, crop = TRUE)\n\nmf_theme(mar = c(0,0,0,0))\nmf_raster(osm_tiles)\nmf_map(com, border = \"grey20\", col = NA, lwd = .7, add = TRUE)\nmf_credits(get_credit(\"OpenStreetMap\"), bg = \"#ffffff80\")\n\n\n\n\n\n\n\n\nDe nombreux styles de tuiles sont disponibles avec le package. En voici quelque uns:\n\nCertains styles ne contiennent que des labels et peuvent être utilisés en complément de données vectorielles:\n\n# Récupération d'un fond de carte OSM des labels\nmf_theme(mar = c(0,0,0,0))\nosm_labels &lt;- get_tiles(x = com, provider = \"CartoDB.PositronOnlyLabels\")\nmf_map(com, col = 'ivory', border = 'ivory3')\nmf_raster(osm_labels, add = T)\nmf_credits(get_credit(\"CartoDB.PositronOnlyLabels\"), bg = \"#ffffff80\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPour certains styles, ceux fournis par Stadia ou Thunderforest par exemple, vous aurez besoin d’une clef d’API. Vous devez vous inscrire sur le site Web de ces fournisseurs pour obtenir une clef.\n\n\n\n\n\n21.0.2 Fonds de cartes vectoriels\n\nLa base de données OpenStreetMap propose de nombreuses couches géographiques très détaillées à l’échelle mondiale. Pour obtenir des informations synthétiques pouvant être utilisées à des fins cartographiques, les couches doivent être sélectionnées, simplifiées, fusionnées ou modifiées. Le package maposm (Giraud, 2025a) fournit un ensemble de couches composites construites à partir d’extractions effectuées avec le package osmdata.\nLes couches proposées sont les suivantes :\n\nles zones urbaines\nles bâtiments\nles espaces verts\nles routes principales\nles outes secondaires\nles voies ferrées\nles étendues d’eau\n\nLe package n’est pas sur le CRAN. Pour l’installer :\n\ninstall.packages(\"maposm\", repos = \"https://riatelab.r-universe.dev\")\n\nom_get() est utilisé pour télécharger, fusionner et simplifier les couches géographiques. om_map() peut être utilisé pour cartographier les couches.\n\nlibrary(maposm)\ncoords &lt;- com_raw[com_raw$NOM_COM == \"Cahors\", ] |&gt;\n  st_geometry() |&gt;\n  st_centroid() |&gt;\n  st_transform(\"EPSG:4326\") |&gt;\n  st_coordinates() |&gt;\n  as.vector()\n\ncahors &lt;- om_get(x = coords, r = 2000)\n\n#&gt; Getting urban areas: 1.548 sec elapsed\n#&gt; Getting buildings: 6.939 sec elapsed\n#&gt; Getting green areas: 1.141 sec elapsed\n#&gt; Getting roads: 0.68 sec elapsed\n#&gt; Getting streets: 1.867 sec elapsed\n#&gt; Getting railways: 0.475 sec elapsed\n#&gt; Getting water bodies: 2.208 sec elapsed\n\nom_map(x = cahors, title = \"Cahors\", theme = \"light\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteSite web de maposm\n\n\n\nGet Map Layers from OpenStreetMap\n\n\n\n\n\n\nGiraud, T. (2025a). maposm: Get Map Layers from OpenStreetMap (version 0.2.0). https://github.com/riatelab/maposm\n\n\nGiraud, T. (2025b). maptiles: Download and Display Map Tiles. https://doi.org/10.32614/CRAN.package.maptiles",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Import de fonds de carte</span>"
    ]
  },
  {
    "objectID": "18_OSM_data.html",
    "href": "18_OSM_data.html",
    "title": "22  Import de données",
    "section": "",
    "text": "22.1 osmdata\nLe package osmdata (Mark Padgham et al., 2017) permet d’extraire des données vectorielles depuis OSM en utilisant l’API Overpass turbo.\nlibrary(sf)\nlibrary(osmdata)\n\n#&gt; Data (c) OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright\n\nlibrary(sf)\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\n\n# Sélection de la commune de Cahors\ncahors &lt;- com[com$INSEE_COM == \"46042\", ]\n\n# Définition d'une bounding box\nq &lt;- opq(bbox = st_bbox(st_transform(cahors, 4326)))\n\n# Extraction des restaurants\nreq &lt;- add_osm_feature(opq = q, key = 'amenity', value = \"restaurant\")\nres &lt;- osmdata_sf(req)\n\n# Réduction du resultats :\n# les points composant les polygones sont supprimés\nres &lt;- unique_osmdata(res)\nLe résultat contient une couche de points et une couche de polygones. Cela signifie que certains restaurants (la très grande majorité) sont enregistrés sous forme de points dans OSM et d’autres sous forme de polygones. Pour obtenir une couche de points cohérente nous pouvons utiliser les centroïdes des polygones.\nresto_point &lt;- res$osm_points\n\n# extraire les centroïdes des polygones\nresto_poly_point &lt;- st_centroid(res$osm_polygons)\n\n#&gt; Warning: st_centroid assumes attributes are constant over geometries\n\n# identifier les champs en commun\nchps &lt;- intersect(names(resto_point), names(resto_poly_point))\n\n# Union des deux couches\nresto &lt;- rbind(resto_point[, chps], resto_poly_point[, chps])\nAffichage des résultats\nlibrary(mapview)\nmapview(cahors) + mapview(resto)",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Import de données</span>"
    ]
  },
  {
    "objectID": "18_OSM_data.html#osmdata",
    "href": "18_OSM_data.html#osmdata",
    "title": "22  Import de données",
    "section": "",
    "text": "NoteSite web d’osmdata\n\n\n\nosmdata",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Import de données</span>"
    ]
  },
  {
    "objectID": "18_OSM_data.html#osmextract",
    "href": "18_OSM_data.html#osmextract",
    "title": "22  Import de données",
    "section": "22.2 osmextract",
    "text": "22.2 osmextract\n Le package osmextract (Gilardi et Lovelace, 2025) permet d’extraire des données depuis une base de données OSM directement. Ce package permet de travailler en local sur des volumes de données très importants et ainsi d’éviter de surcharger un serveur Overpass turbo.\nLa fonction oe_get() permet de télécharger un extrait de la base de données OSM sur une zone particulière et de sélectionner un type d’objet à importer.\nL’argument place correspond au nom du fichier *.pbf accessible sur le site Geofabrik. L’argument extra_tag permet de sélectionner les objets de la base OSM correspondant à une clef particulière (se référer à la documentation d’OSM pour choisir les clefs).\nNous nous intéressons ici à l’ensemble des équipements (clef amenity) enregistrés dans la base OSM sous forme de points en Andorre.\n\nlibrary(osmextract)\n\n#&gt; Data (c) OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright.\n#&gt; Check the package website, https://docs.ropensci.org/osmextract/, for more details.\n\nosm_pt &lt;- oe_get(place = \"Andorra\",      \n                 layer = \"points\", \n                 extra_tags = \"amenity\", \n                 quiet = TRUE)\n\nDes équipements de nature très variés sont saisis dans OSM:\n\nunique(osm_pt$amenity)\n\n#&gt;  [1] NA                       \"parking_entrance\"       \"fuel\"                  \n#&gt;  [4] \"arts_centre\"            \"restaurant\"             \"parking\"               \n#&gt;  [7] \"theatre\"                \"bar\"                    \"hospital\"              \n#&gt; [10] \"atm\"                    \"school\"                 \"pharmacy\"              \n#&gt; [13] \"ski_rental\"             \"fast_food\"              \"toilets\"               \n#&gt; [16] \"bank\"                   \"veterinary\"             \"post_box\"              \n#&gt; [19] \"pub\"                    \"shelter\"                \"car_wash\"              \n#&gt; [22] \"fountain\"               \"cafe\"                   \"post_office\"           \n#&gt; [25] \"bench\"                  \"place_of_worship\"       \"drinking_water\"        \n#&gt; [28] \"recycling\"              \"cinema\"                 \"telephone\"             \n#&gt; [31] \"library\"                \"nightclub\"              \"police\"                \n#&gt; [34] \"kindergarten\"           \"mini_storage\"           \"bbq\"                   \n#&gt; [37] \"courthouse\"             \"car_rental\"             \"dojo\"                  \n#&gt; [40] \"waste_basket\"           \"dentist\"                \"doctors\"               \n#&gt; [43] \"townhall\"               \"bicycle_parking\"        \"sanitary_dump_station\" \n#&gt; [46] \"charging_station\"       \"community_centre\"       \"waste_disposal\"        \n#&gt; [49] \"watering_place\"         \"water_point\"            \"internet_cafe\"         \n#&gt; [52] \"bus_station\"            \"motorcycle_parking\"     \"photo_booth\"           \n#&gt; [55] \"locker\"                 \"shower\"                 \"events_venue\"          \n#&gt; [58] \"public_bookcase\"        \"animal_shelter\"         \"biergarten\"            \n#&gt; [61] \"childcare\"              \"clinic\"                 \"lavoir\"                \n#&gt; [64] \"vending_machine\"        \"bicycle_rental\"         \"compressed_air\"        \n#&gt; [67] \"bicycle_repair_station\" \"taxi\"                   \"parking_space\"         \n#&gt; [70] \"language_school\"\n\n\nNous allons maintenant sélectionner les bars, cafés, pubs et restaurants et les visualiser sur une carte interactive.\n\npoi &lt;- c(\"bar\", \"cafe\", \"pub\", \"restaurant\")\nosm_pt &lt;- osm_pt[osm_pt$amenity %in% poi, ]\nlibrary(leaflet)\npal &lt;- colorFactor(palette = c(\"navy\", \"red\", \"darkgreen\", \"gold\"),\n                   domain = poi)\nleaflet(osm_pt) |&gt;\n  addProviderTiles(\"OpenStreetMap.HOT\") |&gt;\n  addCircleMarkers(radius = 4,\n                   stroke = FALSE,\n                   color = ~ pal(amenity),\n                   fillOpacity = 1,\n                   popup = osm_pt$name) |&gt;\n  addLegend(pal = pal,\n            values = poi,\n            opacity = 0.7,\n            title = \"OSM amenity\",\n            position = \"bottomright\"\n  ) \n\n\n\n\n\n\n\n\n\n\n\nNoteSite web d’osmextract\n\n\n\nosmextract\n\n\n\n\n\n\nGilardi, A. et Lovelace, R. (2025). osmextract: Download and Import Open Street Map Data Extracts. https://doi.org/10.32614/CRAN.package.osmextract\n\n\nMark Padgham, Bob Rudis, Robin Lovelace et Maëlle Salmon. (2017). osmdata. Journal of Open Source Software, 2(14), 305. https://doi.org/10.21105/joss.00305",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Import de données</span>"
    ]
  },
  {
    "objectID": "19_OSM_routing.html",
    "href": "19_OSM_routing.html",
    "title": "23  Matrices de temps et itinéraires",
    "section": "",
    "text": "23.1 Calcul d’un itinéraire\nLe package osrm (Giraud, 2022) sert d’interface entre R et le service de calcul d’itinéraire OSRM (Luxen et Vetter, 2011). Ce package permet de calculer des matrices de temps et de distances, des itinéraires routiers, des isochrones. Le package utilise par défaut le serveur de démo d’OSRM. En cas d’utilisation intensive il est fortement recommandé d’utiliser sa propre instance d’OSRM avec Docker.\nLa fonction osrmRoute() permet de calculer des itinéraires.\nlibrary(sf)\nlibrary(osrm)\nlibrary(maptiles)\n\ncom_raw &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\ncom &lt;- st_transform(com_raw, 3857)\n\n# Itinéraire entre les centroïdes de Cahors et de Puybrun\ncahors  &lt;- st_centroid(com[com$INSEE_COM == \"46042\", ])\npuybrun &lt;- st_centroid(com[com$INSEE_COM == \"46229\", ])\n\nroute &lt;- osrmRoute(src = cahors,\n                   dst = puybrun)\n\n# Récupération d'un fond de carte OSM\nosm &lt;- get_tiles(st_buffer(route, 2000), crop = TRUE)\n\n# Affichage\nmf_theme(mar = c(0,0,0,0))\nmf_raster(osm)\nmf_map(route, col = \"grey10\", lwd = 6, add = T)\nmf_map(route, col = \"grey90\", lwd = 1, add = T)",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Matrices de temps et itinéraires</span>"
    ]
  },
  {
    "objectID": "19_OSM_routing.html#calcul-dune-matrice-de-temps",
    "href": "19_OSM_routing.html#calcul-dune-matrice-de-temps",
    "title": "23  Matrices de temps et itinéraires",
    "section": "23.2 Calcul d’une matrice de temps",
    "text": "23.2 Calcul d’une matrice de temps\nLa fonction osrmTable() permet de calculer des matrices de distances ou de temps par la route.\n\n\n\n\n\n\nNoteGéoréférencement d’adresses ?\n\n\n\nVoir le point Géoréférencement pour le géocodage d’adresse avec R\n\n\nDans cet exemple nous calculons une matrice de temps entre 2 adresses et les restaurants de Cahors à pied.\n\nlibrary(sf)\nlibrary(tidygeocoder)\n\nrestaurant &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\n\n# Sélection des restaurants de Cahors\nrestaurant_cahors &lt;- st_filter(restaurant, com_raw[com_raw$INSEE_COM == \"46042\", ])\n\n# Construction d'un data.frame contenant deux adresses\nadresses &lt;- data.frame(ad = c(\"3 rue Montaudié, Cahors, France\",\n                              \"5 rue Albert Camus, Cahors, France\"))\n\n# Geocodage de 2 adresses à Cahors\nplaces &lt;- geocode(.tbl = adresses,address = ad, quiet = TRUE)\nplaces &lt;- as.data.frame(places)\nrow.names(places) &lt;- c(\"Rue Montaudié\", \"Rue Albert Camus\")\n\n# Calcul de la matrice de distance entre les 2 adresses et les restaurants de Cahors\nmat &lt;- osrmTable(src = places[c(3, 2)],\n                 dst = restaurant_cahors,\n                 osrm.profile = \"foot\")\n\nmat$durations[, 1:5]\n\n#&gt;                     1    2    3    4    5\n#&gt; Rue Montaudié    17.7 21.5 21.9 22.4 14.2\n#&gt; Rue Albert Camus 33.8 65.2 37.8 25.4 35.0\n\n# Quelle adresse possède une meilleure accessibilité aux restaurants ?\nboxplot(t(mat$durations), cex.axis = .7, horizontal = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\nGiraud, T. (2022). osrm: Interface Between R and the OpenStreetMap-Based Routing Service OSRM. Journal of Open Source Software, 7(78), 4574. https://doi.org/10.21105/joss.04574\n\n\nLuxen, D. et Vetter, C. (2011). Real-time routing with OpenStreetMap data. New York, NY, USA (p. 513‑516). https://doi.org/10.1145/2093973.2094062",
    "crumbs": [
      "**Focus sur OpenStreetMap**",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Matrices de temps et itinéraires</span>"
    ]
  },
  {
    "objectID": "1999_georeferencement.html",
    "href": "1999_georeferencement.html",
    "title": "24  Géocodage",
    "section": "",
    "text": "24.1 Géocodage d’adresse avec tidygeocoder\nPlusieurs packages permettent de géocoder des adresses.  Le package tidygeocoder (Cambon et al., 2021) permet d’utiliser un grand nombre de services de géocodage en ligne.\nlibrary(tidygeocoder)\naddress_df &lt;- data.frame(\n  address = c(\"10 Emma Goldmanweg, 5032MN Tilburg, Netherlands\", \n              \"19 rue Michel Bakounine, 29600 Morlaix, France\")\n)\n\nplaces &lt;- geocode(.tbl = address_df, address = \"address\", quiet = TRUE)\nplaces\n\n#&gt; # A tibble: 2 × 3\n#&gt;   address                                           lat  long\n#&gt;   &lt;chr&gt;                                           &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 10 Emma Goldmanweg, 5032MN Tilburg, Netherlands  51.5  5.04\n#&gt; 2 19 rue Michel Bakounine, 29600 Morlaix, France   48.6 -3.82",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Géocodage</span>"
    ]
  },
  {
    "objectID": "1999_georeferencement.html#transformer-des-données-longlat-en-objet-sf",
    "href": "1999_georeferencement.html#transformer-des-données-longlat-en-objet-sf",
    "title": "24  Géocodage",
    "section": "24.2 Transformer des données long/lat en objet sf",
    "text": "24.2 Transformer des données long/lat en objet sf\nLa fonction st_as_sf() permet de créer un objet sf à partir d’un data.frame contenant des coordonnées géographiques.\nIci nous utilisons le data.frame places créé précédement :\n\nlibrary(sf)\nplace_sf &lt;- st_as_sf(places, \n                     coords = c(\"long\", \"lat\"), \n                     crs = 'EPSG:4326')\nplace_sf\n\n#&gt; Simple feature collection with 2 features and 1 field\n#&gt; Geometry type: POINT\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: -3.816434 ymin: 48.59041 xmax: 5.038699 ymax: 51.53649\n#&gt; Geodetic CRS:  WGS 84\n#&gt; # A tibble: 2 × 2\n#&gt;   address                                                     geometry\n#&gt; * &lt;chr&gt;                                                    &lt;POINT [°]&gt;\n#&gt; 1 10 Emma Goldmanweg, 5032MN Tilburg, Netherlands  (5.038699 51.53649)\n#&gt; 2 19 rue Michel Bakounine, 29600 Morlaix, France  (-3.816435 48.59041)\n\n\nPour créer un objet sf de type POINT à partir d’une paire de coordonnées, ici le point de longitude 0.5 et de latitude 45.5 en WGS84 (EPSG:4326), il est nécessaire de créer le data.frame au préalable :\n\nlibrary(sf)\ndf_pt &lt;- data.frame(x = 0.5, y = 45.5)\nmon_point &lt;- st_as_sf(df_pt, coords = c(\"x\", \"y\"), crs = 'EPSG:4326')\nmon_point\n\n#&gt; Simple feature collection with 1 feature and 0 fields\n#&gt; Geometry type: POINT\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 0.5 ymin: 45.5 xmax: 0.5 ymax: 45.5\n#&gt; Geodetic CRS:  WGS 84\n#&gt;           geometry\n#&gt; 1 POINT (0.5 45.5)",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Géocodage</span>"
    ]
  },
  {
    "objectID": "1999_georeferencement.html#affichage-sur-un-fond-openstreetmap",
    "href": "1999_georeferencement.html#affichage-sur-un-fond-openstreetmap",
    "title": "24  Géocodage",
    "section": "24.3 Affichage sur un fond OpenStreetMap",
    "text": "24.3 Affichage sur un fond OpenStreetMap\nNous pouvons afficher cet objet sf sur un fond de carte OpenStreetMap avec le package maptiles (Giraud, 2025).\n\nlibrary(mapsf)\nlibrary(maptiles)\n\n# Reprojection en webmercator\nplace_sf &lt;- st_transform(place_sf, \"EPSG:3857\")\n\n# Récupération d'un fond de carte OSM\nosm &lt;- get_tiles(x = place_sf, zoom = 6)\n\n# Affichage\nmf_theme(mar = c(0,0,0,0))\nmf_raster(osm)\nmf_map(place_sf, pch = 4, cex = 2, lwd = 2, col = \"red\", add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\nCambon, J., Hernangómez, D., Belanger, C. et Possenriede, D. (2021). tidygeocoder: An R package for geocoding. Journal of Open Source Software, 6(65), 3544. https://doi.org/10.21105/joss.03544\n\n\nGiraud, T. (2025). maptiles: Download and Display Map Tiles. https://doi.org/10.32614/CRAN.package.maptiles",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Géocodage</span>"
    ]
  },
  {
    "objectID": "19992_digit.html",
    "href": "19992_digit.html",
    "title": "25  Digitalisation",
    "section": "",
    "text": "Le package mapedit (Appelhans et al., 2025) permet de digitaliser des fonds de carte directement dans R. Mais disons le franchement, bien que pouvant se révéler pratique dans certains cas, ce package ne saurait se substituer aux fonctionnalités d’un SIG pour les tâches de digitalisation importantes.\n\n\n\n\n\nAppelhans, T., Russell, K. et Busetto, L. (2025). mapedit: Interactive Editing of Spatial Data in R. https://doi.org/10.32614/CRAN.package.mapedit",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Digitalisation</span>"
    ]
  },
  {
    "objectID": "2001_donnees.html",
    "href": "2001_donnees.html",
    "title": "26  Packages de données spatiales",
    "section": "",
    "text": "26.1 À l’échelle mondiale\nDe nombreux packages de mise à disposition de données géographiques (géométries et/ou attributs) ont été développés. Il s’agit le plus souvent de packages interfaçant des API qui permettent d’interroger des données mises à disposition sur le Web, directement avec R.\nCe chapitre en présente une liste non exhaustive de packages disponibles sur le CRAN.",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Packages de données spatiales</span>"
    ]
  },
  {
    "objectID": "2001_donnees.html#à-léchelle-mondiale",
    "href": "2001_donnees.html#à-léchelle-mondiale",
    "title": "26  Packages de données spatiales",
    "section": "",
    "text": "rnaturalearth : permet de récupérer les données cartographiques Natural Earth.\n\n cshapes : met à disposition les frontières nationales, de 1886 à aujourd’hui.\n\n osmextract : permet d’importer des données OpenStreetMap.\n\n osmdata : pour télécharger et utiliser les données d’OpenStreetMap.\n maptiles : télécharger, composer et afficher des tuiles à partir d’un grand nombre de fournisseurs.\n\n geonames : permet d’interroger la BD geonames, qui fournit notamment des localisations.\n wbstats et WDI : donnent accès aux données et statistiques de la Banque mondiale.\n\n MODISTools et modisfast : permet de trouver, télécharger et traiter des images MODIS.\n geodata : founit un accès à des données sur le climat, l’altitude, le sol, la présence d’espèces et les limites administratives.\n elevatr : donne accès à des données d’élévation mises à disposition par Amazon Web Services Terrain Tiles, l’Open Topography Global Datasets API et l’USGS Elevation Point Query Service.\n rgee : permet d’utiliser l’API de Google Earth Engine, catalogue de données publiques et infrastructure de calcul pour les images satellites.\n\n nasapower : API client NASA (prévision des ressources énergétiques mondiales, météorologie, énergie solaire de surface et climatologie).\n  rdhs : API client et gestions de données de l’enquête démographique et de santé (DHS).",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Packages de données spatiales</span>"
    ]
  },
  {
    "objectID": "2001_donnees.html#à-léchelle-européenne",
    "href": "2001_donnees.html#à-léchelle-européenne",
    "title": "26  Packages de données spatiales",
    "section": "26.2 À l’échelle européenne",
    "text": "26.2 À l’échelle européenne\n\n giscoR : permet de télécharger des données cartographiques mondiales et européennes de la BD GISCO d’Eurostat (système d’information géographique de la Commission).\n eurostat : permet de télécharger des données de la BD Eurostat.",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Packages de données spatiales</span>"
    ]
  },
  {
    "objectID": "2001_donnees.html#à-léchelle-nationale",
    "href": "2001_donnees.html#à-léchelle-nationale",
    "title": "26  Packages de données spatiales",
    "section": "26.3 À l’échelle nationale",
    "text": "26.3 À l’échelle nationale\n\nBrésil\n\n geobr : fournit un accès facile aux séries de données spatiales officielles du Brésil pour différentes années et découpages administratifs.\n\nChili\n\n chilemapas : donne accès aux divisions politiques et administratives du Chili.\n\nEspagne\n\n mapSpain : propose les limites administratives de l’Espagne à plusieurs niveaux (Communautés autonomes, Provinces, Municipalités), ainsi que des tuiles.\n\nÉtats-Unis\n\n  tidycensus : permet de charger des données et géométries du recensement américain en format sf et tidyverse\n tigris : donne accès aux éléments cartographiques fournis par le US Census Bureau TIGER, y compris les limites cartographiques, les routes et l’eau.\n  FedData : automatise le téléchargement de données géospatiales disponibles à partir de plusieurs sources de données fédérées.\n censusapi : wrapper pour les API du Census Bureau des États-Unis.\n idbr : interface avec l’API de la base de données internationale du US Census Bureau.\n\n ipumsr : Permet d’importer des données de recensement, d’enquête et géographiques fournies par l’IPUMS.\n totalcensus : permet d’extraire les données du recensement décennal et de l’American Community Survey au niveaux des block, block group et tract.\n\nFinland\n\n mapsFinland : donne un accès à des cartes et données concernant la Finlande.\n\nFrance\n\n happign : accès à certaines données de l’IGN.\n insee : pour télécharger facilement les données de la base BDM (Banque de Données Macroéconomiques) de l’INSEE.\n\nPologne\n\n rgugik : permet l’acquisition automatique de données ouvertes à partir des ressources du Bureau central polonais de la géodésie et de la cartographie (Główny Urząd Geodezji i Kartografii).\n\n\n…",
    "crumbs": [
      "**Acquisition de données**",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Packages de données spatiales</span>"
    ]
  },
  {
    "objectID": "2000_references.html",
    "href": "2000_references.html",
    "title": "References",
    "section": "",
    "text": "Agafonkin, V. (s. d.). Leaflet, a JavaScript library for\ninteractive maps. https://leafletjs.com/\n\n\nAppelhans, T., Detsch, F., Reudenbach, C. et Woellauer, S. (2025).\nmapview: Interactive Viewing of Spatial Data in R. https://doi.org/10.32614/CRAN.package.mapview\n\n\nAppelhans, T., Russell, K. et Busetto, L. (2025). mapedit:\nInteractive Editing of Spatial Data in R. https://doi.org/10.32614/CRAN.package.mapedit\n\n\nBéguin, M. et Pumain, D. (2023). La représentation des\ndonnées géographiques: Statistique et\ncartographie. Armand Colin.\n\n\nBertin, J. (1967). Sémiologie Graphique. Les Diagrammes\n- Les Réseaux - Les Cartes. Paris: Mouton &\nGauthier-Villars.\n\n\nBivand, R. (2021). Progress in the R ecosystem for\nrepresenting and handling spatial data. Journal of Geographical\nSystems, 23(4), 515‑546. https://doi.org/10.1007/s10109-020-00336-0\n\n\nBivand, R., Keitt, T. et Rowlingson, B. (2023). rgdal: Bindings for\nthe ’Geospatial’ Data Abstraction Library. https://CRAN.R-project.org/package=rgdal\n\n\nBivand, R. et Rundel, C. (2023). rgeos: Interface to Geometry Engine\n- Open Source (’GEOS’). https://CRAN.R-project.org/package=rgeos\n\n\nBloch, M. (2025). Mapshaper: Tools for editing Shapefile, GeoJSON,\nTopoJSON and CSV files JavaScript libary. https://github.com/mbloch/mapshaper\n\n\nCambon, J., Hernangómez, D., Belanger, C. et Possenriede, D. (2021).\ntidygeocoder: An R package for geocoding. Journal of Open Source\nSoftware, 6(65), 3544. https://doi.org/10.21105/joss.03544\n\n\nCheng, J., Schloerke, B., Karambelkar, B., Xie, Y. et Aden-Buie, G.\n(2025). leaflet: Create Interactive Web Maps with the JavaScript\n’Leaflet’ Library. https://doi.org/10.32614/CRAN.package.leaflet\n\n\nDunnington, D. (2025). ggspatial: Spatial Data Framework for\nggplot2. https://doi.org/10.32614/CRAN.package.ggspatial\n\n\nGDAL/OGR contributors. (2025). GDAL/OGR Geospatial Data\nAbstraction software Library. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.5884351\n\n\nGEOS contributors. (2025). GEOS computational geometry\nlibrary. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.11396894\n\n\nGilardi, A. et Lovelace, R. (2025). osmextract: Download and Import\nOpen Street Map Data Extracts. https://doi.org/10.32614/CRAN.package.osmextract\n\n\nGiraud, T. (2022). osrm: Interface Between R and the\nOpenStreetMap-Based Routing Service OSRM. Journal of Open\nSource Software, 7(78), 4574. https://doi.org/10.21105/joss.04574\n\n\nGiraud, T. (2025a). maplegend: Legends for Maps. https://doi.org/10.32614/CRAN.package.maplegend\n\n\nGiraud, T. (2025b). maposm: Get Map Layers from\nOpenStreetMap (version 0.2.0). https://github.com/riatelab/maposm\n\n\nGiraud, T. (2025c). mapsf: Thematic Cartography.\nhttps://doi.org/10.32614/CRAN.package.mapsf\n\n\nGiraud, T. (2025d). maptiles: Download and Display Map Tiles.\nhttps://doi.org/10.32614/CRAN.package.maptiles\n\n\nGiraud, T. et Lambert, N. (2017). Reproducible Cartography. M.\nPeterson (dir.), Cham, Switzerland (p. 173‑183). https://doi.org/10.1007/978-3-319-57336-6_13\n\n\nHijmans, R. J. (2025a). Spatial Data Science with R and\n\"terra\". https://rspatial.org\n\n\nHijmans, R. J. (2025b). terra: Spatial Data Analysis. https://doi.org/10.32614/CRAN.package.terra\n\n\nLambert, N. et Zanin, C. (2025). Manuel de cartographie: principes,\nméthodes, applications. Armand Colin.\n\n\nLi, X. (2009). Map algebra and beyond : 1. Map algebra for scalar\nfields. https://www.slideserve.com/emmak/topics-powerpoint-ppt-presentation\n\n\nLovelace, R., Nowosad, J. et Muenchow, J. (2025). Geocomputation\nwith R. CRC Press. https://r.geocompx.org/\n\n\nLuxen, D. et Vetter, C. (2011). Real-time routing with OpenStreetMap\ndata. New York, NY, USA (p. 513‑516). https://doi.org/10.1145/2093973.2094062\n\n\nMadelin, M. (2021). Analyse d’images raster (et télédétection). https://mmadelin.github.io/sigr2021/SIGR2021_raster_MM.html.\n\n\nMark Padgham, Bob Rudis, Robin Lovelace et Maëlle Salmon. (2017).\nosmdata. Journal of Open Source Software, 2(14), 305.\nhttps://doi.org/10.21105/joss.00305\n\n\nNowosad, J. (2021). Image processing and all things raster. https://nowosad.github.io/SIGR2021/workshop2/workshop2.html.\n\n\nPebesma, E. (2018). Simple Features for R: Standardized Support\nfor Spatial Vector Data. The R Journal,\n10(1), 439‑446. https://doi.org/10.32614/RJ-2018-009\n\n\nPebesma, E. et Bivand, R. (2005). Classes and methods for spatial data\nin R. R News, 5(2), 9‑13. https://CRAN.R-project.org/doc/Rnews/\n\n\nPebesma, E. et Bivand, R. (2023). Spatial Data Science: With\nApplications in R. Chapman; Hall/CRC. https://doi.org/10.1201/9780429459016\n\n\nPebesma, E., Mailund, T. et Hiebert, J. (2016). Measurement Units in\nR. R Journal, 8(2), 486‑494. https://doi.org/10.32614/RJ-2016-061\n\n\nPROJ contributors. (2025). PROJ coordinate\ntransformation software library. Open Source Geospatial Foundation.\nhttps://doi.org/10.5281/zenodo.5884394\n\n\nRacine, E. B. (2016). The Visual Raster Cheat Sheet. https://rpubs.com/etiennebr/visualraster.\n\n\nRIATE. (2025). Cartographie thématique avec Magrit. https://magrit-formation.github.io/\n\n\nTennekes, M. (2018). tmap: Thematic Maps in R.\nJournal of Statistical Software, 84(6), 1‑39. https://doi.org/10.18637/jss.v084.i06\n\n\nTeucher, A. et Russell, K. (2023). rmapshaper: Client for\n’mapshaper’ for ’Geospatial’ Operations. https://doi.org/10.32614/CRAN.package.rmapshaper\n\n\nTomlin, C. D. (1990). Geographic information systems and\ncartographic modeling. Prentice Hall.\n\n\nWalker, K. (2022). crsuggest: Obtain Suggested Coordinate Reference\nSystem Information for Spatial Data. https://doi.org/10.32614/CRAN.package.crsuggest\n\n\nWickham, H. (2016). ggplot2: Elegant Graphics for Data\nAnalysis. Springer-Verlag New York. https://ggplot2.tidyverse.org\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L. D.,\nFrançois, R., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M.,\nPedersen, T. L., Miller, E., Bache, S. M., Müller, K., Ooms, J.,\nRobinson, D., Seidel, D. P., Spinu, V., Takahashi, K., et\nal.Yutani, H. (2019). Welcome to the tidyverse.\nJournal of Open Source Software, 4(43), 1686. https://doi.org/10.21105/joss.01686",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "2002_data.html",
    "href": "2002_data.html",
    "title": "Annexe A — Les données du projet",
    "section": "",
    "text": "Les données utilisées dans ce document sont stockées dans un projet RStudio. Vous devez le télécharger puis le décompresser sur votre machine. Il vous sera ensuite possible de tester l’ensemble des manipulations proposées dans ce document au sein du projet geodata.\nTélécharger le projet\n lot.gpkg\nCe fichier contient plusieurs couches d’informations.\n\ndepartements : les départements français métropolitains, Admin Express COG Carto 3.0, IGN - 2021;\ncommunes : les communes du département du Lot (46) avec des données sur la population active occupée âgée de 25 à 54 ans, par secteur d’activité et sexe, au lieu de résidence, en 2017, BD CARTO® 4.0, IGN - 2021 & Recensements harmonisés - Séries départementales et communales, INSEE - 2020;\nroutes : les routes de la commune de Gramat et alentours (46128), BD CARTO® 4.0, IGN - 2021;\nrestaurants : les restaurants du Lot, Base permanente des équipements (BPE), INSEE - 2021;\nelevations : une grille régulière de points d’altitude (pas d’1 km), Jarvis A., H.I. Reuter, A. Nelson, E. Guevara, 2008, Hole-filled seamless SRTM data V4, International Centre for Tropical Agriculture (CIAT).\n\n com.csv\nCe fichier tabulaire contient des informations complémentaire sur la population active occupée âgée de 25 à 54 ans, par secteur d’activité et sexe, au lieu de résidence, en 2017, Recensements harmonisés - Séries départementales et communales, INSEE - 2020.\n\nle nombre d’actifs (ACT);\nle nombre d’actifs dans l’industrie (IND);\nla part des actifs dans la population totale (SACT);\nla part des actifs dans l’industrie dans le total des actifs (SACT_IND).\n\n elevation.tif\nUne grille régulière de points d’altitude (pas de 30 mètres environ), Jarvis A., H.I. Reuter, A. Nelson, E. Guevara, 2008, Hole-filled seamless SRTM data V4, International Centre for Tropical Agriculture (CIAT).\nelev.tif est une version reprojetée en Lambert 93 de elevation.tif\n clc_2018.tif\nDonnées CORINE Land Cover, Corine Land Cover (CLC) 2018, Version 2020_20u1 - Copernicus Programme.\nclc.tif est une version reprojetée en Lambert 93 de clc_2018.tif\n Sentinel2A.tif\nDonnées Sentinel, Sentinel, Sentinel-2A, S2A_OPER_MSI_L2A_DS_VGS2_20211012T140548_S20211012T105447_N03.01, 12 Octobre 2021 - Copernicus Programme, téléchargé le 28 décembre 2021.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Les données du projet</span>"
    ]
  }
]